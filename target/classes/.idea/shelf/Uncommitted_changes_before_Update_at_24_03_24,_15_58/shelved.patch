Index: .idea/ing-sw-2024-pucci-santarossa-ruggieri-sciarretta.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<module type=\"JAVA_MODULE\" version=\"4\">\n  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n    <exclude-output />\n    <content url=\"file://$MODULE_DIR$\">\n      <sourceFolder url=\"file://$MODULE_DIR$\" isTestSource=\"false\" />\n    </content>\n    <orderEntry type=\"inheritedJdk\" />\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n    <orderEntry type=\"library\" name=\"fasterxml.jackson.core.annotations\" level=\"project\" />\n    <orderEntry type=\"library\" name=\"fasterxml.jackson.core.databind\" level=\"project\" />\n  </component>\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/ing-sw-2024-pucci-santarossa-ruggieri-sciarretta.iml b/.idea/ing-sw-2024-pucci-santarossa-ruggieri-sciarretta.iml
--- a/.idea/ing-sw-2024-pucci-santarossa-ruggieri-sciarretta.iml	
+++ b/.idea/ing-sw-2024-pucci-santarossa-ruggieri-sciarretta.iml	
@@ -1,13 +1,8 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <module type="JAVA_MODULE" version="4">
-  <component name="NewModuleRootManager" inherit-compiler-output="true">
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
+  <component name="AdditionalModuleElements">
+    <content url="file://$MODULE_DIR$" dumb="true">
       <sourceFolder url="file://$MODULE_DIR$" isTestSource="false" />
     </content>
-    <orderEntry type="inheritedJdk" />
-    <orderEntry type="sourceFolder" forTests="false" />
-    <orderEntry type="library" name="fasterxml.jackson.core.annotations" level="project" />
-    <orderEntry type="library" name="fasterxml.jackson.core.databind" level="project" />
   </component>
 </module>
\ No newline at end of file
Index: src/main/java/it/polimi/ingsw/model/Game.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\n\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.LinkedList;\n\npublic class Game {\n    private Queue<Player> playerQueue;\n    private int currentPlayerIndex;\n    private Player firstPlayer;\n    private boolean gameOver;\n    private CommonBoard common_board;\n    private ConcreteDeck resource_deck;\n    private ConcreteDeck gold_deck;\n\n\n    public Game(CommonBoard common_board) {\n        playerQueue = new LinkedList<>();\n        this.common_board = common_board; //initializes the board\n        dealCards();\n        while (!isGameOver()) {\n            // Loop through players and handle each player's turn\n            for (Player player : playerQueue) {\n                //placeCard(chooseCardToPlayFromHand());\n                updatePersonalScore(currentPlayerIndex);\n                drawCard(); //TODO: pesco da terra o dal mazzo a seconda di cosa sceglie l'utente\n            }\n            gameOver = isGameOver();\n        }\n        lastTurn();\n        calculateFinalScores();\n\n\n        // Perform end game actions (e.g., display winner)\n    }\n\n    public void addPlayer(Player player) {\n        playerQueue.add(player);\n    }\n\n\n    public void dealCards() {\n        // Deal cards to players\n        for (Player player : playerQueue) {\n            // Deal 2 cards from the resource deck\n            for (int i = 0; i < 2; i++) {\n                if (!resource_deck.isEmpty()) {\n                    Card card = resource_deck.pop(); // Remove the top card from the resource deck\n                    player.addToHand(card); // Add the card to the player's hand\n                }\n            }\n\n            // Deal 1 card from the gold deck\n            if (!gold_deck.isEmpty()) {\n                Card card = gold_deck.pop(); // Remove the top card from the gold deck\n                player.addToHand(card); // Add the card to the player's hand\n            }\n\n            //TODO: capire se vogliamo prendere 2 obiettivi dal deck obiettivi o scegliere 2 carte a caso\n        }\n    }\n\n\n    public int getCurrentPlayer() {\n        return currentPlayerIndex;\n    }\n\n\n    public void calculateFinalScores() {\n        // Calculate final scores\n        //Riceve da commonBoard le posizioni dell'ultimo giro + da personalBoard i punteggi degli obiettivi, per ciascun giocatore\n        //somma per ogni giocatore\n    }\n\n    public boolean isGameOver() {\n        return gameOver;\n    }\n\n//    public Card chooseCardToPlayFromHand() {\n//\n//    }\n\n    public void placeCard(Card card_chosen) {\n\n    }\n\n    public void updatePersonalScore(int currentPlayerIndex){\n\n    }\n\n    public void drawCard(){\n       //pattern dividere tra pesca da mazzo o dal banco (metodi già scritti in CommonBoard)\n    }\n\n    public void lastTurn(){\n        //gestisce il settaggio del partial_winner + tiene conto del fatto che sto giocando l'ultimo turno\n        //movePlayer (In commonBard notifica quando si arriva a 20, il game fa finire il turno corrente, ne fa fare un'altro completo\n        //e poi arresta il gioco\n    }\n\n\n    // Additional methods and logic as needed\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/Game.java b/src/main/java/it/polimi/ingsw/model/Game.java
--- a/src/main/java/it/polimi/ingsw/model/Game.java	
+++ b/src/main/java/it/polimi/ingsw/model/Game.java	
@@ -89,7 +89,7 @@
     }
 
     public void drawCard(){
-       //pattern dividere tra pesca da mazzo o dal banco (metodi già scritti in CommonBoard)
+        //pattern dividere tra pesca da mazzo o dal banco (metodi già scritti in CommonBoard)
     }
 
     public void lastTurn(){
@@ -101,4 +101,3 @@
 
     // Additional methods and logic as needed
 }
-
Index: src/test/java/it/polimi/ingsw/model/PersonalBoardTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class PersonalBoardTest {\n    private PersonalBoard personalBoard;\n\n    @BeforeEach\n    public void setup() {\n        personalBoard = new PersonalBoard();\n    }\n\n    @Test\n    public void testUpdateMushrooms() {\n        personalBoard.updateMushrooms(5);\n        assertEquals(5, personalBoard.getNum_mushrooms());\n    }\n\n    @Test\n    public void testUpdateLeaves() {\n        personalBoard.updateLeaves(3);\n        assertEquals(3, personalBoard.getNum_leaves());\n    }\n\n    @Test\n    public void testBruteForcePlaceCardAtSE() {\n        // Create a ResourceCard object\n        ResourceCard card = new ResourceCard(1, Orientation.FRONT, Color.RED);\n\n        // Place the card at a specific position on the board\n        personalBoard.bruteForcePlaceCardSE(card, 0, 0);\n\n        // Verify that the card has been placed correctly\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++) {\n                assertEquals(card.getCornerAt(i, j), personalBoard.board[i][j].getCornerFromCell());\n            }\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/it/polimi/ingsw/model/PersonalBoardTest.java b/src/test/java/it/polimi/ingsw/model/PersonalBoardTest.java
--- a/src/test/java/it/polimi/ingsw/model/PersonalBoardTest.java	(revision bda45290e9e2116474db4bd12e1958bb6f1b12a6)
+++ b/src/test/java/it/polimi/ingsw/model/PersonalBoardTest.java	(date 1711292317611)
@@ -12,6 +12,12 @@
         personalBoard = new PersonalBoard();
     }
 
+    @Test
+    public void testConstructorAndGetters() {
+        assertEquals(1005, personalBoard.getDim1());
+        assertEquals(1005, personalBoard.getDim2());
+    }
+
     @Test
     public void testUpdateMushrooms() {
         personalBoard.updateMushrooms(5);
@@ -24,19 +30,4 @@
         assertEquals(3, personalBoard.getNum_leaves());
     }
 
-    @Test
-    public void testBruteForcePlaceCardAtSE() {
-        // Create a ResourceCard object
-        ResourceCard card = new ResourceCard(1, Orientation.FRONT, Color.RED);
-
-        // Place the card at a specific position on the board
-        personalBoard.bruteForcePlaceCardSE(card, 0, 0);
-
-        // Verify that the card has been placed correctly
-        for (int i = 0; i < 2; i++) {
-            for (int j = 0; j < 2; j++) {
-                assertEquals(card.getCornerAt(i, j), personalBoard.board[i][j].getCornerFromCell());
-            }
-        }
-    }
 }
Index: src/main/java/it/polimi/ingsw/model/CardsCollection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Optional;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Iterator;\n\n\npublic  class CardsCollection {\n    public List<Card> cards;\n\n    public CardsCollection() {\n        cards = new ArrayList<>();\n    }\n\n    public void addCard(Card card) {\n        cards.add(card);\n    }\n\n    public int size() {\n        return cards.size();\n    }\n\n    /**\n     * To do: populateDeck read a .json file and populate the data structure using\n     * the constructors and the setters of Card subclasses.\n     */\n    // In this case we are creating only the FRONT, but we need also the back of the card.\n    public void populateDeck(String jsonFilePath, String type) {\n        ObjectMapper objectMapper = new ObjectMapper();\n        try {\n            JsonNode rootNode = objectMapper.readTree(new File(jsonFilePath));\n            JsonNode cardsNode = rootNode.path(\"cards\");\n\n            for (JsonNode cardNode : cardsNode) {\n\n                int id = cardNode.path(\"id\").asInt();\n                String colorStr = cardNode.path(\"color\").asText();\n                Color color = Color.valueOf(colorStr.toUpperCase());\n                Orientation orientation = Orientation.FRONT;\n                int score = cardNode.path(\"points\").asInt();\n\n                // This is the case where we have to create a ResourceCard.\n                // NE corner.\n                Corner[][] actual_corners = new Corner[2][2];\n                String NE_corner_content = cardNode.path(\"NE\").asText();\n                if (NE_corner_content.equals(\"NonVisible\")) {\n                    actual_corners[0][1].is_visible = false;\n                } else {\n                        actual_corners[0][1].setCornerResource(Resource.valueOf(NE_corner_content.toUpperCase()));\n                }\n                // SE Corner.\n                String SE_corner_content = cardNode.path(\"SE\").asText();\n                if (SE_corner_content.equals(\"NonVisible\")) {\n                    actual_corners[1][0].is_visible = false;\n                } else {\n                        actual_corners[1][0].setCornerResource(Resource.valueOf(SE_corner_content.toUpperCase()));\n                }\n                // NO corner.\n                String NO_corner_content = cardNode.path(\"NO\").asText();\n                if (NO_corner_content.equals(\"NonVisible\")) {\n                    actual_corners[0][1].is_visible = false;\n                } else {\n                        actual_corners[0][1].setCornerResource(Resource.valueOf(NO_corner_content.toUpperCase()));\n                }\n                // SO corner.\n                String SO_corner_content = cardNode.path(\"SO\").asText();\n                if (SO_corner_content.equals(\"NonVisible\")) {\n                    actual_corners[1][1].is_visible = false;\n                } else {\n                        actual_corners[1][1].setCornerResource(Resource.valueOf(SO_corner_content.toUpperCase()));\n                }\n\n                if (cardNode.path(\"type\").asText().equals(\"Resource\") && type.equals(\"Resource\")){\n                    ResourceCard card = new ResourceCard(id, orientation, color, score, actual_corners);\n                    // Qui potresti settare ulteriori proprietà specifiche per ResourceCard\n                    this.addCard(card);\n                }\n\n                if (cardNode.path(\"type\").asText().equals(\"Gold\") && type.equals(\"Gold\")){\n                    int MushroomRequired = cardNode.path(\"MushroomRequired\").asInt();\n                    int ButterflyRequired = cardNode.path(\"ButterflyRequired\").asInt();\n                    int WolfRequired = cardNode.path(\"WolfRequired\").asInt();\n                    int LeafRequired = cardNode.path(\"LeafRequired\").asInt();\n\n                    // Item_for_score\n                    int PotionCount = cardNode.path(\"PotionCount\").asInt();\n                    int FeatherCount = cardNode.path(\"FeatherCount\").asInt();\n                    int ParchmentCount = cardNode.path(\"ParchmentCount\").asInt();\n                    int CoverCorners = cardNode.path(\"CoverCorners\").asInt();\n\n                    // Problem: Item optional!\n                    Optional<Item> item_for_score = Optional.empty();\n                    if (PotionCount == 1) {\n                        item_for_score = Optional.of(Item.POTION);\n                    }\n                    if (FeatherCount == 1) {\n                        item_for_score = Optional.of(Item.FEATHER);\n                    }\n                    if (ParchmentCount == 1) {\n                        item_for_score = Optional.of(Item.PARCHMENT);\n                    }\n\n                    GoldCard gold_card = new GoldCard(id, orientation, color);\n                    gold_card.setGoldCard(item_for_score, CoverCorners, MushroomRequired, LeafRequired, ButterflyRequired, WolfRequired);\n                    this.addCard(gold_card);\n                }\n            }\n            System.out.println(\"Deck populated successfully.\");\n        } catch (Exception e) {\n            System.err.println(\"Error populating deck: \" + e.getMessage());\n        }\n    }\n\n    // populate objective cards draft\n    public void populateDeckObjective(String jsonFilePath) {\n        ObjectMapper objectMapper = new ObjectMapper();\n        try {\n            JsonNode rootNode = objectMapper.readTree(new File(jsonFilePath));\n            JsonNode cardsNode = rootNode.path(\"cards\");\n\n            for (JsonNode cardNode : cardsNode) {\n\n                int id = cardNode.path(\"id\").asInt();\n                Orientation orientation = Orientation.FRONT;\n                int points = cardNode.path(\"points\").asInt();\n                String pattern = cardNode.path(\"pattern\").asText();\n                if (pattern.equals(\"L\")) {\n                    LetterPatternObjectiveCard card = new LetterPatternObjectiveCard(id, orientation, points);\n                    card.init_obj_L();\n                    // come si implementa?? come si collegano??\n                    this.addCard(card);\n                }\n                if (pattern.equals(\"J\")) {\n                    LetterPatternObjectiveCard card = new LetterPatternObjectiveCard(id, orientation, points);\n                    card.init_obj_J();\n                    this.addCard(card);\n                }\n                if (pattern.equals(\"P\")) {\n                    LetterPatternObjectiveCard card = new LetterPatternObjectiveCard(id, orientation, points);\n                    this.addCard(card);\n                }\n                if (pattern.equals(\"Q\")) {\n                    LetterPatternObjectiveCard card = new LetterPatternObjectiveCard(id, orientation, points);\n                    card.init_obj_q();\n                    this.addCard(card);\n                }\n                if (pattern.equals(\"increasingDiagonal\")) {\n                    DiagonalPatternObjectiveCard card = new DiagonalPatternObjectiveCard(id, orientation, points);\n                    String color = cardNode.path(\"color1\").asText();\n                    card.init_objIncreasingDiagonal(Color.valueOf(color.toUpperCase()));\n                    this.addCard(card);\n                }\n                if (pattern.equals(\"decreasingDiagonal\")) {\n                    DiagonalPatternObjectiveCard card = new DiagonalPatternObjectiveCard(id, orientation, points);\n                    String color = cardNode.path(\"color1\").asText();\n                    card.init_objDecreasingDiagonal(Color.valueOf(color.toUpperCase()));\n                    this.addCard(card);\n                }\n                if (pattern== null) {\n                    // Completa quando le classi di objective sono finite.\n\n\n                }\n            }\n            System.out.println(\"Objective cards Deck populated successfully.\");\n        } catch (Exception e) {\n            System.err.println(\"Error populating objective cards deck: \" + e.getMessage());\n        }\n    }\n\n    // populate starter cards draft: it create the starter card collection, both front and back of the card. At the end\n    // we have a collections of starter cards, that has size X2.\n    public void populateDeckStarterFrontAndBack(String jsonFilePath) {\n        ObjectMapper objectMapper = new ObjectMapper();\n        try {\n            JsonNode rootNode = objectMapper.readTree(new File(jsonFilePath));\n            JsonNode cardsNode = rootNode.path(\"cards\");\n\n            for (JsonNode cardNode : cardsNode) {\n                int id = cardNode.path(\"id\").asInt();\n                String permanent_resource1 = cardNode.path(\"permanentResource1\").asText();\n                String permanent_resource2 = cardNode.path(\"permanentResource2\").asText();\n                String permanent_resource3 = cardNode.path(\"permanentResource3\").asText();\n                int front_visible_corner = cardNode.path(\"frontVisibleCorner\").asInt();\n                String front_NE= cardNode.path(\"frontNE\").asText();\n                String front_SE = cardNode.path(\"frontSE\").asText();\n                String front_NO = cardNode.path(\"frontNW\").asText();\n                String front_SO = cardNode.path(\"frontSW\").asText();\n                int back_visible_corner = cardNode.path(\"backVisibleCorner\").asInt();\n                String back_NE= cardNode.path(\"backNE\").asText();\n                String back_SE = cardNode.path(\"backSE\").asText();\n                String back_NO = cardNode.path(\"backNW\").asText();\n                String back_SO = cardNode.path(\"backSW\").asText();\n\n                StarterCard card_front = new StarterCard(id, Orientation.FRONT);\n                Corner[][] actual_corners_front = new Corner[2][2];\n                // Front of the Starter Card\n                if (front_NE.equals(\"NonVisible\")) {\n                    actual_corners_front[0][1].is_visible = false;\n                } else {\n                        actual_corners_front[0][1].setCornerResource(Resource.valueOf(front_NE.toUpperCase()));}\n                if (front_SE.equals(\"NonVisible\")) {\n                    actual_corners_front[1][0].is_visible = false;\n                } else {\n                    actual_corners_front[1][0].setCornerResource(Resource.valueOf(front_SE.toUpperCase()));}\n                if (front_NO.equals(\"NonVisible\")) {\n                    actual_corners_front[0][0].is_visible = false;\n                } else {\n                    actual_corners_front[0][0].setCornerResource(Resource.valueOf(front_NO.toUpperCase()));}\n                if (front_SO.equals(\"NonVisible\")) {\n                    actual_corners_front[1][1].is_visible = false;\n                } else {\n                    actual_corners_front[1][1].setCornerResource(Resource.valueOf(front_SO.toUpperCase()));}\n                // Back of the Starter Card\n                StarterCard card_back = new StarterCard(id, Orientation.BACK);\n                Corner[][] actual_corners_back = new Corner[2][2];\n\n                if (back_NE.equals(\"NonVisible\")) {\n                    actual_corners_back[0][1].is_visible = false;\n                } else {\n                    actual_corners_back[0][1].setCornerResource(Resource.valueOf(back_NE.toUpperCase()));}\n                if (back_SE.equals(\"NonVisible\")) {\n                    actual_corners_back[1][0].is_visible = false;\n                } else {\n                    actual_corners_back[1][0].setCornerResource(Resource.valueOf(back_SE.toUpperCase()));}\n                if (back_NO.equals(\"NonVisible\")) {\n                    actual_corners_back[0][0].is_visible = false;\n                } else {\n                    actual_corners_back[0][0].setCornerResource(Resource.valueOf(back_NO.toUpperCase()));}\n                if (back_SO.equals(\"NonVisible\")) {\n                    actual_corners_back[1][1].is_visible = false;\n                } else {\n                    actual_corners_back[1][1].setCornerResource(Resource.valueOf(back_SO.toUpperCase()));}\n\n                // Remark: read carefully the Starter Card class. Here we create at the same moment two cards: the first that is the front, and the second one is the back of the same card.\n                // But they are two different objects, they have in common the same id!\n\n                card_front.SetStarterCardFront(Resource.valueOf(permanent_resource1.toUpperCase()), Resource.valueOf(permanent_resource2.toUpperCase()), Resource.valueOf(permanent_resource3.toUpperCase()), actual_corners_front);\n                card_back.setStarterCardBack(actual_corners_back);\n            }\n            System.out.println(\"Starter cards Deck populated successfully.\");\n        } catch (Exception e) {\n            System.err.println(\"Error populating starter cards deck: \" + e.getMessage());\n        }\n\n    }\n\n\n\n    }\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/CardsCollection.java b/src/main/java/it/polimi/ingsw/model/CardsCollection.java
--- a/src/main/java/it/polimi/ingsw/model/CardsCollection.java	
+++ b/src/main/java/it/polimi/ingsw/model/CardsCollection.java	
@@ -27,7 +27,7 @@
     }
 
     /**
-     * To do: populateDeck read a .json file and populate the data structure using
+     * TODO: populateDeck read a .json file and populate the data structure using
      * the constructors and the setters of Card subclasses.
      */
     // In this case we are creating only the FRONT, but we need also the back of the card.
