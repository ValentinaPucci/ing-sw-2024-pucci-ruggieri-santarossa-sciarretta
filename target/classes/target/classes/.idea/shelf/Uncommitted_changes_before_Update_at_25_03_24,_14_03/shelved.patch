Index: src/main/java/it/polimi/ingsw/model/PersonalBoard.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\n\nimport it.polimi.ingsw.model.exceptions.IllegalMoveException;\n\npublic class PersonalBoard {\n\n    public static final int BOARD_CENTER = 50;\n    public Cell[][] board;\n    private int dim1;\n    private int dim2;\n    private int points;\n    private int delta_points;\n    private int num_mushrooms;\n    private int num_leaves;\n    private int num_butterflies;\n    private int num_wolves;\n    private int num_parchments;\n    private int num_feathers;\n    private int num_potions;\n\n    public PersonalBoard() {\n        this.dim1 = 1005;\n        this.dim2 = 1005;\n\n        this.board = new Cell[dim1][dim2];\n        for (int i = 0; i < dim1; i++) {\n            for (int j = 0; j < dim2; j++) {\n                this.board[i][j] = new Cell();\n            }\n        }\n\n        this.points = 0;\n        this.delta_points = 20;\n        this.num_mushrooms = 0;\n        this.num_leaves = 0;\n        this.num_butterflies = 0;\n        this.num_wolves = 0;\n        this.num_parchments = 0;\n        this.num_feathers = 0;\n        this.num_potions = 0;\n    }\n\n    /**\n     * @param dim\n     */\n    public PersonalBoard(int dim) {\n        this.dim1 = dim;\n        this.dim2 = dim;\n\n        this.board = new Cell[dim1][dim2];\n        for (int i = 0; i < dim1; i++) {\n            for (int j = 0; j < dim2; j++) {\n                this.board[i][j] = new Cell();\n            }\n        }\n\n        this.points = 0;\n        this.delta_points = 20;\n        this.num_mushrooms = 0;\n        this.num_leaves = 0;\n        this.num_butterflies = 0;\n        this.num_wolves = 0;\n        this.num_parchments = 0;\n        this.num_feathers = 0;\n        this.num_potions = 0;\n    }\n\n    /**\n     * @param dim1\n     * @param dim2\n     */\n    public PersonalBoard(int dim1, int dim2) {\n        this.dim1 = dim1;\n        this.dim2 = dim2;\n\n        this.board = new Cell[dim1][dim2];\n        for (int i = 0; i < dim1; i++) {\n            for (int j = 0; j < dim2; j++) {\n                this.board[i][j] = new Cell();\n            }\n        }\n\n        this.points = 0;\n        this.delta_points = 20;\n        this.num_mushrooms = 0;\n        this.num_leaves = 0;\n        this.num_butterflies = 0;\n        this.num_wolves = 0;\n        this.num_parchments = 0;\n        this.num_feathers = 0;\n        this.num_potions = 0;\n    }\n\n    public int getDeltaPoints(){return delta_points;} //Used in Game\n\n    /**\n     * @param mushrooms_placed\n     */\n    public void updateMushrooms(int mushrooms_placed) {\n        this.num_mushrooms += mushrooms_placed;\n    }\n\n    /**\n     * @param leaves_placed\n     */\n    public void updateLeaves(int leaves_placed) {\n        this.num_leaves += leaves_placed;\n    }\n\n    /**\n     * @param butterflies_placed\n     */\n    public void updateButterflies(int butterflies_placed) {\n        this.num_butterflies += butterflies_placed;\n    }\n\n    /**\n     * @param wolves_placed\n     */\n    public void updateWolves(int wolves_placed) {\n        this.num_wolves += wolves_placed;\n    }\n\n    /**\n     * @param parchments_placed\n     */\n    public void updateParchments(int parchments_placed) {\n        this.num_parchments += parchments_placed;\n    }\n\n    /**\n     * @param feathers_placed\n     */\n    public void updateFeathers(int feathers_placed) {\n        this.num_feathers += feathers_placed;\n    }\n\n    /**\n     * @param potions_placed\n     */\n    public void updatePotions(int potions_placed) {\n        this.num_potions += potions_placed;\n    }\n    // SarÃ  necesario anche aggiornare i punti, ma servono i controlli sulla carta da piazzare.\n\n    /**\n     * @param points_of_placed_card\n     */\n    public void updatePoints(int points_of_placed_card) {\n        //Se piazzo carta oro che mi fa guadagnare punti, ma solo se rispetta i vincoli correttamente.\n        this.points += points_of_placed_card;\n        this.delta_points = delta_points - points_of_placed_card;\n    }\n\n    public int getNum_mushrooms() {\n        return num_mushrooms;\n    }\n\n    public int getNum_leaves() {\n        return num_leaves;\n    }\n\n    public int getNum_butterflies() {\n        return num_butterflies;\n    }\n\n    public int getNum_wolves() {\n        return num_wolves;\n    }\n\n    public int getNum_parchments() {\n        return num_parchments;\n    }\n\n    public int getNum_feathers() {\n        return num_feathers;\n    }\n\n    public int getNum_potions() {\n        return num_potions;\n    }\n\n    public int getPoints() {\n        return points;\n    }\n\n    public int getDim1() {\n        return dim1;\n    }\n\n    public int getDim2() {\n        return dim2;\n    }\n\n    /**\n     * @param i\n     * @param j\n     * @return true iff the planed move is doable\n     */\n    public boolean subMatrixCellChecker(int i, int j) {\n        for (int k = 0; k < 2; k++) {\n            for (int h = 0; h < 2; h++) {\n                if (board[i + k][j + h].is_full) {\n                    if (!board[i + k][j + h].getCornerFromCell().is_visible\n                            || board[i + k][j + h].level > 2) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * This method simply put a card at position (i,j) of the board\n     * without doing any check. It is used for the placement of the first\n     * card or in other marginal situations, like for the construction of\n     * sub-matrices of personalBoard in other classes. SE because we use\n     * a classic for loop with increasing indexes both for i and j.\n     *\n     * @param card\n     */\n    public void bruteForcePlaceCardSE(ResourceCard card, int i, int j) {\n        for (int k = 0; k < 2; k++) {\n            for (int h = 0; h < 2; h++) {\n                this.board[i + k][j + h].setCellAsFull(card.getCornerAt(k, h));\n            }\n        }\n    }\n\n    public void bruteForcePlaceStarterCard(StarterCard card) {\n        for (int k = 0; k < 2; k++) {\n            for (int h = 0; h < 2; h++) {\n                this.board[BOARD_CENTER + k][BOARD_CENTER + h].setCellAsFull(card.getCornerAt(k, h));\n            }\n        }\n    }\n\n\n\n\n    /**\n     * We assume that the game_card's corners have a specified board_coordinate,\n     *\n     * @param game_card    is the card already on the PersonalBoard\n     * @param card_to_play is the card to put on the PersonalBoard\n     * @ensures card_to_play is attached to another card, specifically in the NE corner\n     * of the game_card\n     */\n    public void placeCardAtNE(ResourceCard game_card, ResourceCard card_to_play)\n            throws IllegalMoveException {\n\n        /**\n         * The following attributes are the starting point in the grid\n         * to perform the 'allocation' (namely, the placement) of the\n         * card_to_play on the PersonalBoard.\n         */\n        int i;\n        int j;\n\n        Corner corner2 = game_card.getCornerAtNE();\n\n        if (!corner2.is_visible)\n            throw new IllegalMoveException();\n\n        i = corner2.board_coordinate.getX();\n        j = corner2.board_coordinate.getY();\n\n        /**\n         * i + 1 is a technicality: the checker starts always\n         * form the position (0, 0) of the submatrix 2 x 2 it is\n         * analyzing.\n         */\n        if (!subMatrixCellChecker(i + 1, j))\n            throw new IllegalMoveException();\n\n        /**\n         * we can forget to take **directly** track of the items or\n         * the resources which are currently on the board at a certain position,\n         * because we know every corner in a given cell. Hence, we know the resources\n         * and/or the items in every cell.\n         */\n        for (int k = 1; k >= 0; k--) {\n            for (int h = 0; h < 2; h++) {\n                this.board[i + k][j + h].setCellAsFull(card_to_play.getCornerAt(k, h));\n            }\n        }\n    }\n\n    /**\n     * @param game_card    is the card already on the PersonalBoard\n     * @param card_to_play is the card to put on the PersonalBoard\n     * @ensures card_to_play is attached to another card, specifically in the SE corner\n     * of the game_card\n     */\n    public void placeCardAtSE(ResourceCard game_card, ResourceCard card_to_play)\n            throws IllegalMoveException {\n\n        int i;\n        int j;\n\n        Corner corner2 = game_card.getCornerAtSE();\n\n        if (!corner2.is_visible)\n            throw new IllegalMoveException();\n\n        i = corner2.board_coordinate.getX();\n        j = corner2.board_coordinate.getY();\n\n        if (!subMatrixCellChecker(i, j))\n            throw new IllegalMoveException();\n\n        for (int k = 0; k < 2; k++) {\n            for (int h = 0; h < 2; h++) {\n                this.board[i + k][j + h].setCellAsFull(card_to_play.getCornerAt(k, h));\n            }\n        }\n    }\n\n    /**\n     * @param game_card    is the card already on the PersonalBoard\n     * @param card_to_play is the card to put on the PersonalBoard\n     * @ensures card_to_play is attached to another card, specifically in the SO corner\n     * of the game_card\n     */\n    public void placeCardAtSO(ResourceCard game_card, ResourceCard card_to_play)\n            throws IllegalMoveException {\n\n        int i;\n        int j;\n\n        Corner corner2 = game_card.getCornerAtSO();\n\n        if (!corner2.is_visible)\n            throw new IllegalMoveException();\n\n        i = corner2.board_coordinate.getX();\n        j = corner2.board_coordinate.getY();\n\n        if (!subMatrixCellChecker(i, j - 1))\n            throw new IllegalMoveException();\n\n        for (int k = 0; k < 2; k++) {\n            for (int h = 1; h >= 0; h--) {\n                this.board[i + k][j + h].setCellAsFull(card_to_play.getCornerAt(k, h));\n            }\n        }\n    }\n\n    /**\n     * @param game_card    is the card already on the PersonalBoard\n     * @param card_to_play is the card to put on the PersonalBoard\n     * @ensures card_to_play is attached to another card, specifically in the NO corner\n     * of the game_card\n     */\n    public void placeCardAtNO(ResourceCard game_card, ResourceCard card_to_play)\n            throws IllegalMoveException {\n\n        int i;\n        int j;\n\n        Corner corner2 = game_card.getCornerAtNO();\n\n        if (!corner2.is_visible)\n            throw new IllegalMoveException();\n\n        i = corner2.board_coordinate.getX();\n        j = corner2.board_coordinate.getY();\n\n        if (!subMatrixCellChecker(i + 1, j - 1))\n            throw new IllegalMoveException();\n\n        for (int k = 1; k >= 0; k--) {\n            for (int h = 1; h >= 0; h--) {\n                this.board[i + k][j + h].setCellAsFull(card_to_play.getCornerAt(k, h));\n            }\n        }\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/PersonalBoard.java b/src/main/java/it/polimi/ingsw/model/PersonalBoard.java
--- a/src/main/java/it/polimi/ingsw/model/PersonalBoard.java	(revision 1df1c4f484263f87d81c3f3d7784b8fda214594b)
+++ b/src/main/java/it/polimi/ingsw/model/PersonalBoard.java	(date 1711371502772)
@@ -329,7 +329,7 @@
         int i;
         int j;
 
-        Corner corner2 = game_card.getCornerAtSO();
+        Corner corner2 = game_card.getCornerAtSW();
 
         if (!corner2.is_visible)
             throw new IllegalMoveException();
@@ -359,7 +359,7 @@
         int i;
         int j;
 
-        Corner corner2 = game_card.getCornerAtNO();
+        Corner corner2 = game_card.getCornerAtNW();
 
         if (!corner2.is_visible)
             throw new IllegalMoveException();
Index: src/main/java/it/polimi/ingsw/model/Game.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\n\nimport java.util.*;\n\nimport static it.polimi.ingsw.model.enumerations.Coordinate;\n\npublic class Game {\n    private Queue<Player> player_queue;\n    private Player[] players;\n    private int num_players;\n    private boolean game_over;\n    private boolean last_turn;\n    private CommonBoard common_board;\n    private ConcreteDeck resource_deck;\n    private ConcreteDeck gold_deck;\n    private ConcreteDeck objective_deck;\n    private int[] final_scores;\n    private Player winner;\n    private Player temp_winner;\n    private Coordinate coordinate;\n    private ResourceCard already_placed_card;\n    private StarterCard starter_card;\n    private int from_where_draw;\n    private int from_which_deckindex;\n    private int col;\n    private int row;\n\n\n\n\n    public Game(CommonBoard common_board, Player[] players) {\n        this.player_queue = new LinkedList<>();\n        this.players = players;\n        this.num_players = players.length;\n        this.game_over = false;\n        this.last_turn = false;\n        this.final_scores = new int[num_players];\n        this.common_board = common_board;\n        this.resource_deck = common_board.getResourceConcreteDeck();\n        this.gold_deck = common_board.getGoldConcreteDeck();\n        this.objective_deck = common_board.getObjectiveConcreteDeck();\n        // Aggiunta dei giocatori alla coda dei giocatori\n        for (Player player : players) {\n            this.player_queue.offer(player);\n        }\n        this.coordinate = NE; // default\n        this.from_where_draw = 0;\n        this.from_which_deckindex = 0;\n        this.col = 0;\n        this.row = 0;;\n\n    }\n\n    public void gameFlow(){\n        initializeGame();\n        for(Player player: player_queue){\n            player.playStarterCard();\n        }\n        while (!isGameOver()) {\n            while (!isLastTurn()) {\n                // Loop through players and handle each player's turn\n                for (Player player : player_queue) {\n                    placeCard(player.getChosenGameCard(), player.getPersonalBoard(), coordinate, already_placed_card);\n                    PersonalBoard current_board = player.getPersonalBoard();\n                    int delta = current_board.getDeltaPoints();\n                    common_board.movePlayer(player.getId(), delta);\n                    drawCard(from_where_draw);\n                    if(common_board.getPartialWinner() != -1)\n                        last_turn = true;\n                }\n            }\n            secondLastTurn();\n        }\n        calculateFinalScores();\n        setWinner();\n    }\n\n    public void initializeGame(){\n        common_board.initializeBoard();\n        dealCards();\n    }\n\n\n    public void dealCards() {\n        // Deal cards to players\n        for (Player player : player_queue) {\n            // Deal 2 cards from the resource deck\n            for (int i = 0; i < 2; i++) {\n                if (!resource_deck.isEmpty()) {\n                    Card card = resource_deck.pop(); // Remove the top card from the resource deck\n                    player.addToHand(card); // Add the card to the player's hand\n                }\n            }\n\n            // Deal 1 card from the gold deck\n            if (!gold_deck.isEmpty()) {\n                Card card = gold_deck.pop(); // Remove the top card from the gold deck\n                player.addToHand(card); // Add the card to the player's hand\n            }\n\n            for (int i = 0; i < 2; i++) {\n                if (!objective_deck.isEmpty()) {\n                    ObjectiveCard card1 = (ObjectiveCard)objective_deck.pop();\n                    ObjectiveCard card2 = (ObjectiveCard)objective_deck.pop();\n                    player.setSecretObjectives(card1, card2);\n                }\n            }\n        }\n    }\n\n\n    public void calculateFinalScores() {\n        for(int i= 0; i<players.length - 1; i++)\n            final_scores[i] = players[i].getPersonalBoard().getPoints();\n\n    }\n\n    public void placeCard(ResourceCard card_chosen, PersonalBoard personal_board, Coordinate coordinate, ResourceCard already_placed_card) {\n        switch (coordinate){\n            case NE:\n                personal_board.placeCardAtNE(already_placed_card, card_chosen);\n            case SE:\n                personal_board.placeCardAtSE(already_placed_card, card_chosen);\n            case SW:\n                personal_board.placeCardAtSO(already_placed_card, card_chosen);\n            case NW:\n                personal_board.placeCardAtNO(already_placed_card, card_chosen);\n        }\n\n    }\n    public void setCoordinate(Coordinate coordinate) {\n        this.coordinate = coordinate;\n    }\n    public void setAlreadyPlacedCard(ResourceCard card) {\n        this.already_placed_card = card;\n    }\n\n\n\n    public void drawCard(int where){\n        switch (where){\n            case 0:\n                common_board.drawFromConcreteDeck(from_which_deckindex);\n            case 1:\n                common_board.drawFromTable(row, col, from_which_deckindex);\n        }\n    }\n\n    public void setFromWhereDraw(int where) {\n        this.from_where_draw = where;\n        //Convention to avoid creating another enum\n        //0: from concrete deck\n        //1: from table\n    }\n\n    public void setFromConcreteDeck(int index) {\n        this.from_which_deckindex = index;\n    }\n\n    public void setFromTable(int row, int col, int index) {\n        this.row = row;\n        this.col = col;\n        this.from_which_deckindex = index;}\n\n    public boolean isLastTurn() {\n        return last_turn;\n    }\n\n    public void lastTurn(){\n        for (int i = 0; i < num_players; i++) {\n            Player currentPlayer = player_queue.poll();\n            //il giocatore gioca\n            player_queue.offer(currentPlayer); // Rimetti il giocatore corrente in fondo alla coda\n        }\n        game_over = true;\n    }\n\n    public void secondLastTurn(){\n        for (int i = common_board.getPartialWinner(); i < num_players; i++) {\n            Player currentPlayer = player_queue.poll();\n            //il giocatore gioca\n            player_queue.offer(currentPlayer); // Rimetti il giocatore corrente in fondo alla coda\n        }\n        lastTurn();\n    }\n\n    public boolean isGameOver() {\n        return game_over;\n    }\n\n\n    public Player getWinner(){\n        return winner;\n    }\n\n    public void setWinner(){\n        int temp_score = 0;\n        temp_winner = players[0];\n\n        for(int i= 0; i<players.length - 1; i++)\n            if (final_scores[i] > temp_score) {\n                temp_score = final_scores[i];\n                temp_winner = players[i];\n            }\n        this.winner = temp_winner;\n    }\n\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/Game.java b/src/main/java/it/polimi/ingsw/model/Game.java
--- a/src/main/java/it/polimi/ingsw/model/Game.java	(revision 1df1c4f484263f87d81c3f3d7784b8fda214594b)
+++ b/src/main/java/it/polimi/ingsw/model/Game.java	(date 1711371279274)
@@ -2,7 +2,7 @@
 
 import java.util.*;
 
-import static it.polimi.ingsw.model.enumerations.Coordinate;
+import it.polimi.ingsw.model.enumerations.Coordinate;
 
 public class Game {
     private Queue<Player> player_queue;
