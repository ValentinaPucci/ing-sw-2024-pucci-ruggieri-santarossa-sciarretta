Index: src/main/java/it/polimi/ingsw/model/GoldCard.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\n\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.HashSet;\n\npublic class GoldCard extends ResourceCard {\n\n    // Attributes to calculate the score based on items or darken coordinates on the personal board;\n    private Optional<Item> item_for_score;\n    // 0=false, 1=true, the card has the darken_items requirements to calculate the score.\n    private int coordinate_for_score;\n    private int mushroom_required;\n    private int leaf_required;\n    private int butterfly_required;\n    private int wolf_required;\n\n    /**\n     *\n     * @param id\n     * @param orientation\n     */\n    public GoldCard(int id, Orientation orientation, Color color) {\n        super(id, orientation, color);\n    }\n\n    /**\n     * Setter method for GoldCard.\n     * @param item_for_score\n     * @param coordinate_for_score\n     */\n    public void setGoldCard(Optional<Item> item_for_score, int coordinate_for_score, int mushroom_required, int leaf_required, int butterfly_required, int wolf_required) {\n        this.item_for_score = item_for_score;\n        this.coordinate_for_score = coordinate_for_score;\n        this.mushroom_required = mushroom_required;\n        this.leaf_required = leaf_required;\n        this.butterfly_required = butterfly_required;\n        this.wolf_required = wolf_required;\n    }\n\n    /**\n     * 'filler' methods must be used every time we have to 'populate' a certain\n     * data structures\n     * @param resources\n     */\n//    public void fillResourcesRequired(Set<Resource> resources) {\n//        resources_required.addAll(resources);\n//    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/GoldCard.java b/src/main/java/it/polimi/ingsw/model/GoldCard.java
--- a/src/main/java/it/polimi/ingsw/model/GoldCard.java	(revision 044f0df272e71ce727f5c92f6c619c0dd6e15752)
+++ b/src/main/java/it/polimi/ingsw/model/GoldCard.java	(date 1711303382381)
@@ -1,8 +1,10 @@
 package it.polimi.ingsw.model;
 
+import it.polimi.ingsw.model.enumerations.Color;
+import it.polimi.ingsw.model.enumerations.Item;
+import it.polimi.ingsw.model.enumerations.Orientation;
+
 import java.util.Optional;
-import java.util.Set;
-import java.util.HashSet;
 
 public class GoldCard extends ResourceCard {
 
Index: src/main/java/it/polimi/ingsw/model/PersonalBoard.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\n\npublic class PersonalBoard {\n    public Cell[][] board;\n\n    private int dim1;\n    private int dim2;\n    private int points;\n    private int delta_points;\n    private int num_mushrooms;\n    private int num_leaves;\n    private int num_butterflies;\n    private int num_wolves;\n    private int num_parchments;\n    private int num_feathers;\n    private int num_potions;\n\n    public PersonalBoard() {\n        this.dim1 = 1005;\n        this.dim2 = 1005;\n\n        this.board = new Cell[dim1][dim2];\n        for (int i = 0; i < dim1; i++) {\n            for (int j = 0; j < dim2; j++) {\n                this.board[i][j] = new Cell();\n            }\n        }\n\n        this.points = 0;\n        this.delta_points = 20;\n        this.num_mushrooms = 0;\n        this.num_leaves = 0;\n        this.num_butterflies = 0;\n        this.num_wolves = 0;\n        this.num_parchments = 0;\n        this.num_feathers = 0;\n        this.num_potions = 0;\n    }\n\n    /**\n     * @param dim\n     */\n    public PersonalBoard(int dim) {\n        this.dim1 = dim;\n        this.dim2 = dim;\n\n        this.board = new Cell[dim1][dim2];\n        for (int i = 0; i < dim1; i++) {\n            for (int j = 0; j < dim2; j++) {\n                this.board[i][j] = new Cell();\n            }\n        }\n\n        this.points = 0;\n        this.delta_points = 20;\n        this.num_mushrooms = 0;\n        this.num_leaves = 0;\n        this.num_butterflies = 0;\n        this.num_wolves = 0;\n        this.num_parchments = 0;\n        this.num_feathers = 0;\n        this.num_potions = 0;\n    }\n\n    /**\n     * @param dim1\n     * @param dim2\n     */\n    public PersonalBoard(int dim1, int dim2) {\n        this.dim1 = dim1;\n        this.dim2 = dim2;\n\n        this.board = new Cell[dim1][dim2];\n        for (int i = 0; i < dim1; i++) {\n            for (int j = 0; j < dim2; j++) {\n                this.board[i][j] = new Cell();\n            }\n        }\n\n        this.points = 0;\n        this.delta_points = 20;\n        this.num_mushrooms = 0;\n        this.num_leaves = 0;\n        this.num_butterflies = 0;\n        this.num_wolves = 0;\n        this.num_parchments = 0;\n        this.num_feathers = 0;\n        this.num_potions = 0;\n    }\n\n    public int getDeltaPoints(){return delta_points;} //Used in Game\n\n    /**\n     * @param mushrooms_placed\n     */\n    public void updateMushrooms(int mushrooms_placed) {\n        this.num_mushrooms += mushrooms_placed;\n    }\n\n    /**\n     * @param leaves_placed\n     */\n    public void updateLeaves(int leaves_placed) {\n        this.num_leaves += leaves_placed;\n    }\n\n    /**\n     * @param butterflies_placed\n     */\n    public void updateButterflies(int butterflies_placed) {\n        this.num_butterflies += butterflies_placed;\n    }\n\n    /**\n     * @param wolves_placed\n     */\n    public void updateWolves(int wolves_placed) {\n        this.num_wolves += wolves_placed;\n    }\n\n    /**\n     * @param parchments_placed\n     */\n    public void updateParchments(int parchments_placed) {\n        this.num_parchments += parchments_placed;\n    }\n\n    /**\n     * @param feathers_placed\n     */\n    public void updateFeathers(int feathers_placed) {\n        this.num_feathers += feathers_placed;\n    }\n\n    /**\n     * @param potions_placed\n     */\n    public void updatePotions(int potions_placed) {\n        this.num_potions += potions_placed;\n    }\n    // SarÃ  necesario anche aggiornare i punti, ma servono i controlli sulla carta da piazzare.\n\n    /**\n     * @param points_of_placed_card\n     */\n    public void updatePoints(int points_of_placed_card) {\n        //Se piazzo carta oro che mi fa guadagnare punti, ma solo se rispetta i vincoli correttamente.\n        this.points += points_of_placed_card;\n        this.delta_points = delta_points - points_of_placed_card;\n    }\n\n    public int getNum_mushrooms() {\n        return num_mushrooms;\n    }\n\n    public int getNum_leaves() {\n        return num_leaves;\n    }\n\n    public int getNum_butterflies() {\n        return num_butterflies;\n    }\n\n    public int getNum_wolves() {\n        return num_wolves;\n    }\n\n    public int getNum_parchments() {\n        return num_parchments;\n    }\n\n    public int getNum_feathers() {\n        return num_feathers;\n    }\n\n    public int getNum_potions() {\n        return num_potions;\n    }\n\n    public int getPoints() {\n        return points;\n    }\n\n    public int getDim1() {\n        return dim1;\n    }\n\n    public int getDim2() {\n        return dim2;\n    }\n\n    /**\n     * @param i\n     * @param j\n     * @return true iff the planed move is doable\n     */\n    public boolean subMatrixCellChecker(int i, int j) {\n        for (int k = 0; k < 2; k++) {\n            for (int h = 0; h < 2; h++) {\n                if (board[i + k][j + h].is_full) {\n                    if (!board[i + k][j + h].getCornerFromCell().is_visible\n                            || board[i + k][j + h].level > 2) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * This method simply put a card at position (i,j) of the board\n     * without doing any check. It is used for the placement of the first\n     * card or in other marginal situations, like for the construction of\n     * sub-matrices of personalBoard in other classes. SE because we use\n     * a classic for loop with increasing indexes both for i and j.\n     *\n     * @param card\n     */\n    public void bruteForcePlaceCardSE(ResourceCard card, int i, int j) {\n        for (int k = 0; k < 2; k++) {\n            for (int h = 0; h < 2; h++) {\n                this.board[i + k][j + h].setCellAsFull(card.getCornerAt(k, h));\n            }\n        }\n    }\n\n    /**\n     * We assume that the game_card's corners have a specified board_coordinate,\n     *\n     * @param game_card    is the card already on the PersonalBoard\n     * @param card_to_play is the card to put on the PersonalBoard\n     * @ensures card_to_play is attached to another card, specifically in the NE corner\n     * of the game_card\n     */\n    public void placeCardAtNE(ResourceCard game_card, ResourceCard card_to_play)\n            throws IllegalMoveException {\n\n        /**\n         * The following attributes are the starting point in the grid\n         * to perform the 'allocation' (namely, the placement) of the\n         * card_to_play on the PersonalBoard.\n         */\n        int i;\n        int j;\n\n        Corner corner2 = game_card.getCornerAtNE();\n\n        if (!corner2.is_visible)\n            throw new IllegalMoveException();\n\n        i = corner2.board_coordinate.getX();\n        j = corner2.board_coordinate.getY();\n\n        /**\n         * i + 1 is a technicality: the checker starts always\n         * form the position (0, 0) of the submatrix 2 x 2 it is\n         * analyzing.\n         */\n        if (!subMatrixCellChecker(i + 1, j))\n            throw new IllegalMoveException();\n\n        /**\n         * we can forget to take **directly** track of the items or\n         * the resources which are currently on the board at a certain position,\n         * because we know every corner in a given cell. Hence, we know the resources\n         * and/or the items in every cell.\n         */\n        for (int k = 1; k >= 0; k--) {\n            for (int h = 0; h < 2; h++) {\n                this.board[i + k][j + h].setCellAsFull(card_to_play.getCornerAt(k, h));\n            }\n        }\n    }\n\n    /**\n     * @param game_card    is the card already on the PersonalBoard\n     * @param card_to_play is the card to put on the PersonalBoard\n     * @ensures card_to_play is attached to another card, specifically in the SE corner\n     * of the game_card\n     */\n    public void placeCardAtSE(ResourceCard game_card, ResourceCard card_to_play)\n            throws IllegalMoveException {\n\n        int i;\n        int j;\n\n        Corner corner2 = game_card.getCornerAtSE();\n\n        if (!corner2.is_visible)\n            throw new IllegalMoveException();\n\n        i = corner2.board_coordinate.getX();\n        j = corner2.board_coordinate.getY();\n\n        if (!subMatrixCellChecker(i, j))\n            throw new IllegalMoveException();\n\n        for (int k = 0; k < 2; k++) {\n            for (int h = 0; h < 2; h++) {\n                this.board[i + k][j + h].setCellAsFull(card_to_play.getCornerAt(k, h));\n            }\n        }\n    }\n\n    /**\n     * @param game_card    is the card already on the PersonalBoard\n     * @param card_to_play is the card to put on the PersonalBoard\n     * @ensures card_to_play is attached to another card, specifically in the SO corner\n     * of the game_card\n     */\n    public void placeCardAtSO(ResourceCard game_card, ResourceCard card_to_play)\n            throws IllegalMoveException {\n\n        int i;\n        int j;\n\n        Corner corner2 = game_card.getCornerAtSO();\n\n        if (!corner2.is_visible)\n            throw new IllegalMoveException();\n\n        i = corner2.board_coordinate.getX();\n        j = corner2.board_coordinate.getY();\n\n        if (!subMatrixCellChecker(i, j - 1))\n            throw new IllegalMoveException();\n\n        for (int k = 0; k < 2; k++) {\n            for (int h = 1; h >= 0; h--) {\n                this.board[i + k][j + h].setCellAsFull(card_to_play.getCornerAt(k, h));\n            }\n        }\n    }\n\n    /**\n     * @param game_card    is the card already on the PersonalBoard\n     * @param card_to_play is the card to put on the PersonalBoard\n     * @ensures card_to_play is attached to another card, specifically in the NO corner\n     * of the game_card\n     */\n    public void placeCardAtNO(ResourceCard game_card, ResourceCard card_to_play)\n            throws IllegalMoveException {\n\n        int i;\n        int j;\n\n        Corner corner2 = game_card.getCornerAtNO();\n\n        if (!corner2.is_visible)\n            throw new IllegalMoveException();\n\n        i = corner2.board_coordinate.getX();\n        j = corner2.board_coordinate.getY();\n\n        if (!subMatrixCellChecker(i + 1, j - 1))\n            throw new IllegalMoveException();\n\n        for (int k = 1; k >= 0; k--) {\n            for (int h = 1; h >= 0; h--) {\n                this.board[i + k][j + h].setCellAsFull(card_to_play.getCornerAt(k, h));\n            }\n        }\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/PersonalBoard.java b/src/main/java/it/polimi/ingsw/model/PersonalBoard.java
--- a/src/main/java/it/polimi/ingsw/model/PersonalBoard.java	(revision 044f0df272e71ce727f5c92f6c619c0dd6e15752)
+++ b/src/main/java/it/polimi/ingsw/model/PersonalBoard.java	(date 1711303209479)
@@ -1,5 +1,7 @@
 package it.polimi.ingsw.model;
 
+import it.polimi.ingsw.model.exceptions.IllegalMoveException;
+
 public class PersonalBoard {
     public Cell[][] board;
 
Index: src/main/java/it/polimi/ingsw/model/StarterCard.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\n\npublic class StarterCard extends Card {\n    public static final int STARTER_CARD_COORDINATE = 50;\n    private Resource front_resource1;\n    private Resource front_resource2;\n    private Resource front_resource3;\n    private Corner[][] back_corners;\n    private Orientation orientation;\n\n    /**\n     *\n     * @param id\n     * @param orientation\n     */\n    public StarterCard(int id, Orientation orientation) {\n        super(id, orientation);\n        this.front_resource1 = null;\n        this.front_resource2 = null;\n        this.front_resource3 = null;\n        this.back_corners = new Corner[4][4];\n    }\n\n    /**\n     *\n     * @param resource1\n     * @param resource2\n     */\n    public void SetStarterCardFront(Resource resource1, Resource resource2, Resource resource3, Corner[][] actual_corners){\n        this.front_resource1 = resource1;\n        this.front_resource2 = resource2;\n        this.front_resource3 = resource3;\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                this.back_corners[i][j] = actual_corners[i][j];\n            }\n        }\n    }\n\n    /**\n     *\n     * @param score\n     * @param actual_corners\n     * @param resource\n     * @param item\n     */\n    public void setStarterCardBack(Corner[][] actual_corners) {\n        this.front_resource1 = null;\n        this.front_resource2 = null;\n        this.front_resource3 = null;\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                this.back_corners[i][j] = actual_corners[i][j];\n            }\n        }\n    }\n\n}\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/StarterCard.java b/src/main/java/it/polimi/ingsw/model/StarterCard.java
--- a/src/main/java/it/polimi/ingsw/model/StarterCard.java	(revision 044f0df272e71ce727f5c92f6c619c0dd6e15752)
+++ b/src/main/java/it/polimi/ingsw/model/StarterCard.java	(date 1711303382407)
@@ -1,5 +1,8 @@
 package it.polimi.ingsw.model;
 
+import it.polimi.ingsw.model.enumerations.Orientation;
+import it.polimi.ingsw.model.enumerations.Resource;
+
 public class StarterCard extends Card {
     public static final int STARTER_CARD_COORDINATE = 50;
     private Resource front_resource1;
Index: src/main/java/it/polimi/ingsw/model/ObjectiveCard.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\n\npublic abstract class ObjectiveCard extends Card {\n    private int points;\n\n    /**\n     * @param id\n     * @param orientation\n     */\n    public ObjectiveCard(int id, Orientation orientation, int points) {\n        super(id, orientation);\n        this.points = points;\n    }\n\n    public int getPoints() {\n        return points;\n    }\n\n    public abstract int calculateScore(PersonalBoard personal_board);\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/ObjectiveCard.java b/src/main/java/it/polimi/ingsw/model/ObjectiveCard.java
--- a/src/main/java/it/polimi/ingsw/model/ObjectiveCard.java	(revision 044f0df272e71ce727f5c92f6c619c0dd6e15752)
+++ b/src/main/java/it/polimi/ingsw/model/ObjectiveCard.java	(date 1711305682362)
@@ -1,20 +1,33 @@
 package it.polimi.ingsw.model;
 
+import it.polimi.ingsw.model.enumerations.Orientation;
+
 public abstract class ObjectiveCard extends Card {
     private int points;
 
     /**
-     * @param id
-     * @param orientation
+     * Costruttore protetto per evitare istanziazione diretta
+     * @param id l'id dell'obiettivo
+     * @param orientation front o back
+     * @param points il punteggio dell'obiettivo
      */
-    public ObjectiveCard(int id, Orientation orientation, int points) {
+    protected ObjectiveCard(int id, Orientation orientation, int points) {
         super(id, orientation);
         this.points = points;
     }
 
+    /**
+     * Metodo per ottenere il punteggio dell'obiettivo
+     * @return il punteggio dell'obiettivo
+     */
     public int getPoints() {
         return points;
     }
 
+    /**
+     * Metodo astratto per calcolare il punteggio dell'obiettivo in base allo schema personale del giocatore
+     * @param personal_board lo schema personale del giocatore
+     * @return il punteggio calcolato dell'obiettivo
+     */
     public abstract int calculateScore(PersonalBoard personal_board);
 }
Index: src/main/java/it/polimi/ingsw/model/ResourceObjectiveCard.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\n\npublic class ResourceObjectiveCard extends ObjectiveCard {\n\n    /**\n     * @param id\n     * @param orientation\n     */\n    public ResourceObjectiveCard(int id, Orientation orientation, int points) {\n        super(id, orientation, points);\n    }\n\n    @Override\n    public int calculateScore(PersonalBoard personal_board) {\n        return personal_board.getNum_mushrooms() + personal_board.getNum_leaves();\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/ResourceObjectiveCard.java b/src/main/java/it/polimi/ingsw/model/ResourceObjectiveCard.java
--- a/src/main/java/it/polimi/ingsw/model/ResourceObjectiveCard.java	(revision 044f0df272e71ce727f5c92f6c619c0dd6e15752)
+++ b/src/main/java/it/polimi/ingsw/model/ResourceObjectiveCard.java	(date 1711303382369)
@@ -1,5 +1,7 @@
 package it.polimi.ingsw.model;
 
+import it.polimi.ingsw.model.enumerations.Orientation;
+
 public class ResourceObjectiveCard extends ObjectiveCard {
 
     /**
Index: src/main/java/it/polimi/ingsw/model/Corner.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\n\nimport java.util.Optional;\nimport java.util.NoSuchElementException;\n\n/**\n * This class is thought to be complementary to the class Cell.\n * Indeed Corner class has to interact in some way with Cell class.\n * Moreover, the importance of this class is mainly related to the fact\n * that we need to 'track' the resources and the items which are present\n * inside the PersonalBoard.\n */\npublic class Corner {\n\n    private Coordinate coordinate;\n    private Optional<Resource> resource;\n    private Optional<Item> item;\n    public boolean is_visible;\n    public ResourceCard reference_card;\n\n    /**\n     * In fact, this attribute make a lot of sense: board_coordinate\n     * is not the effective coordinate of the corner inside the board\n     */\n    public BoardCellCoordinate board_coordinate;\n\n    /**\n     *\n     * @param board_coordinate\n     */\n    public Corner(BoardCellCoordinate board_coordinate) {\n        this.board_coordinate = board_coordinate;\n        this.is_visible = true;\n    }\n\n    /**\n     *\n     * @param coordinate\n     * @param resource\n     * @param item\n     * @param is_visible\n     * @param card\n     */\n    public Corner(Coordinate coordinate, Optional<Resource> resource, Optional<Item> item,\n                  boolean is_visible, ResourceCard card) {\n        this.coordinate = coordinate;\n        this.resource = resource;\n        this.item = item;\n        this.is_visible = is_visible;\n        this.reference_card = card;\n        this.board_coordinate = new BoardCellCoordinate(0, 0);\n        this.board_coordinate.setXY(coordinate);\n    }\n\n    // Set corner\n// Crea un set resource. per settare resource e poi crea anche un set item per settare item.\n    public void setCornerResource(Resource resource){\n        this.resource = Optional.ofNullable(resource);\n    }\n\n    public void setCornerItem(Item item){\n        this.item = Optional.ofNullable(item);\n    }\n\n    public void setBoard_coordinate(Coordinate coord) {\n        this.board_coordinate.setXY(coord);\n    }\n\n    /**\n     * to check\n     * @return\n     * @throws NoSuchElementException\n     */\n    public Resource getResource() throws NoSuchElementException {\n        return resource.get();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        Corner corner = (Corner) obj;\n        if (this.is_visible && corner.is_visible) {\n            if (this.resource.isPresent() && corner.resource.isPresent()) {\n                return this.resource.get().equals(corner.resource.get());\n            } else {\n                return false;\n            }\n        }\n        else\n            return false;\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/Corner.java b/src/main/java/it/polimi/ingsw/model/Corner.java
--- a/src/main/java/it/polimi/ingsw/model/Corner.java	(revision 044f0df272e71ce727f5c92f6c619c0dd6e15752)
+++ b/src/main/java/it/polimi/ingsw/model/Corner.java	(date 1711303382401)
@@ -1,5 +1,9 @@
 package it.polimi.ingsw.model;
 
+import it.polimi.ingsw.model.enumerations.Coordinate;
+import it.polimi.ingsw.model.enumerations.Item;
+import it.polimi.ingsw.model.enumerations.Resource;
+
 import java.util.Optional;
 import java.util.NoSuchElementException;
 
Index: src/main/java/it/polimi/ingsw/model/DiagonalPatternObjectiveCard.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\n\n/**\n * The following class describe those objective cards that deal\n * with ** diagonal ** patter recognition of cards with respect to the board configuration:\n * There are 2 possible (geometric) patterns of three cards each. In order to distinguish\n * the cards in the patter to recognise, we only need to know the color of each. It is useful\n * to implements some methods that can achieve our goals in terms of sub-matrices encoding.\n */\npublic class DiagonalPatternObjectiveCard extends ObjectiveCard {\n\n    /**\n     * This attributes let us use all the methods we\n     * implemented in Personal board. Dim = 4 x 4;\n     */\n    public PersonalBoard aux_personal_board;\n    public ScoreStrategy score_strategy;\n\n    /**\n     * @param id\n     * @param orientation\n     * @param points\n     */\n    public DiagonalPatternObjectiveCard(int id, Orientation orientation, int points) {\n        super(id, orientation, points);\n        this.aux_personal_board = new PersonalBoard(4);\n        this.score_strategy = new DiagonalPatternScoreStrategy();\n    }\n\n    /**\n     * This method is an initializer; in fact we initialize auxiliary\n     * cards that are out of the deck. In general their id does not make\n     * any sense. For the sake of simplicity, we assume that those cards\n     * have id set to -1;\n     *\n     * Remark: Both increasing diagonal pattern and decreasing diagonal\n     * pattern deal with cards of the SAME color.\n     *\n     * @requires\n     *      color == RED || color == BLUE\n     * @param color\n     */\n    public void init_objIncreasingDiagonal(Color color) {\n\n        ResourceCard card1 = new ResourceCard(-1, Orientation.FRONT, color);\n        ResourceCard card2 = new ResourceCard(-1, Orientation.FRONT, color);\n        ResourceCard card3 = new ResourceCard(-1, Orientation.FRONT, color);\n\n        aux_personal_board.bruteForcePlaceCardSE(card1, 0, 0);\n        aux_personal_board.placeCardAtSE(card1, card2);\n        aux_personal_board.placeCardAtSE(card2, card3);\n\n    }\n\n    /**\n     * Symmetric method to the previous one\n     *\n     * @requires\n     *      color == GREEN || color == PURPLE\n     *\n     * @param color\n     */\n    public void init_objDecreasingDiagonal(Color color) {\n        ResourceCard card1 = new ResourceCard(-1, Orientation.FRONT, color);\n        ResourceCard card2 = new ResourceCard(-1, Orientation.FRONT, color);\n        ResourceCard card3 = new ResourceCard(-1, Orientation.FRONT, color);\n\n        aux_personal_board.bruteForcePlaceCardSE(card1, 2, 0);\n        aux_personal_board.placeCardAtNE(card1, card2);\n        aux_personal_board.placeCardAtNE(card2, card3);\n    }\n\n    @Override\n    public int calculateScore(PersonalBoard personal_board) {\n        return score_strategy.calculateScore(this, personal_board);\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/DiagonalPatternObjectiveCard.java b/src/main/java/it/polimi/ingsw/model/DiagonalPatternObjectiveCard.java
--- a/src/main/java/it/polimi/ingsw/model/DiagonalPatternObjectiveCard.java	(revision 044f0df272e71ce727f5c92f6c619c0dd6e15752)
+++ b/src/main/java/it/polimi/ingsw/model/DiagonalPatternObjectiveCard.java	(date 1711303382377)
@@ -1,5 +1,8 @@
 package it.polimi.ingsw.model;
 
+import it.polimi.ingsw.model.enumerations.Color;
+import it.polimi.ingsw.model.enumerations.Orientation;
+
 /**
  * The following class describe those objective cards that deal
  * with ** diagonal ** patter recognition of cards with respect to the board configuration:
Index: src/main/java/it/polimi/ingsw/model/Player.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Player {\n    private int id;\n    private String username;\n    private List<Card> card_hand;\n    private PersonalBoard personal_board; // correspondence between PersonalBoard and Player\n    private ObjectiveCard[] secret_objectives;\n    private ObjectiveCard chosen_objective;\n    private StarterCard starter_card;\n    private boolean partial_winner;\n    private boolean final_winner;\n    private ResourceCard chosen_card;\n    private int score_board_position;\n    private int final_score;\n\n   public Player(int id, String username) {\n        this.id = id;\n        this.username = username;\n        this.card_hand = new ArrayList<>();\n        this.personal_board = new PersonalBoard();\n        this.secret_objectives = new ArrayList<>();\n        this.chosen_objective = null;\n        this.starter_card = null;\n        this.partial_winner = false;\n        this.final_winner = false;\n        this.score_board_position = 0;\n        this.final_score = 0;\n    }\n\n    public void setObjectiveCard(ObjectiveCard chosen_objective) {//TODO: deck o no?\n        this.chosen_objective = chosen_objective;\n    }\n\n    public void playStarterCard() {\n       //call brute force starter card from personal board\n    }\n    public int getId(){return id;}\n\n    public PersonalBoard getPersonalBoard() {\n        return personal_board;\n    }\n\n    public void setChosenGameCard(ResourceCard chosen_card) { //choose the card you want to play from your hand\n        // la scelta arriva dal controller\n        this.chosen_card = chosen_card;\n    }\n\n    public ResourceCard getChosenGameCard() {\n        return this.chosen_card;\n    }\n\n    public void addToHand(Card card){\n       this.card_hand.add(card);\n    }\n    public void setPartialWinner(boolean partial_winner) { //choose the card you want to play from your hand\n        // la scelta arriva dalla logica\n        this.partial_winner = partial_winner;\n    }\n\n    public void setSecretObjectives(ObjectiveCard objective1, ObjectiveCard objective2){\n        secret_objectives[0] = objective1;\n        secret_objectives[1] = objective2;\n    }\n\n    public void setFinalWinner(boolean final_winner) { //choose the card you want to play from your hand\n        this.final_winner = final_winner;\n    }\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/Player.java b/src/main/java/it/polimi/ingsw/model/Player.java
--- a/src/main/java/it/polimi/ingsw/model/Player.java	(revision 044f0df272e71ce727f5c92f6c619c0dd6e15752)
+++ b/src/main/java/it/polimi/ingsw/model/Player.java	(date 1711302991800)
@@ -22,7 +22,8 @@
         this.username = username;
         this.card_hand = new ArrayList<>();
         this.personal_board = new PersonalBoard();
-        this.secret_objectives = new ArrayList<>();
+        this.secret_objectives[0] = null;
+        this.secret_objectives[1] = null;
         this.chosen_objective = null;
         this.starter_card = null;
         this.partial_winner = false;
Index: src/main/java/it/polimi/ingsw/model/Item.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/Item.java b/src/main/java/it/polimi/ingsw/model/enumerations/Item.java
rename from src/main/java/it/polimi/ingsw/model/Item.java
rename to src/main/java/it/polimi/ingsw/model/enumerations/Item.java
--- a/src/main/java/it/polimi/ingsw/model/Item.java	(revision 044f0df272e71ce727f5c92f6c619c0dd6e15752)
+++ b/src/main/java/it/polimi/ingsw/model/enumerations/Item.java	(date 1711303382393)
@@ -1,4 +1,4 @@
-package it.polimi.ingsw.model;
+package it.polimi.ingsw.model.enumerations;
 
 public enum Item {
     POTION,
Index: src/main/java/it/polimi/ingsw/model/IllegalMoveException.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/IllegalMoveException.java b/src/main/java/it/polimi/ingsw/model/exceptions/IllegalMoveException.java
rename from src/main/java/it/polimi/ingsw/model/IllegalMoveException.java
rename to src/main/java/it/polimi/ingsw/model/exceptions/IllegalMoveException.java
--- a/src/main/java/it/polimi/ingsw/model/IllegalMoveException.java	(revision 044f0df272e71ce727f5c92f6c619c0dd6e15752)
+++ b/src/main/java/it/polimi/ingsw/model/exceptions/IllegalMoveException.java	(date 1711303209472)
@@ -1,4 +1,4 @@
-package it.polimi.ingsw.model;
+package it.polimi.ingsw.model.exceptions;
 
 public class IllegalMoveException extends RuntimeException {
     public IllegalMoveException() {
Index: src/main/java/it/polimi/ingsw/model/Card.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\n\npublic abstract class Card {\n    private int id;\n    public Orientation orientation;\n\n    /**\n     *\n     */\n    public Card(int id, Orientation orientation) {\n        this.id = id;\n        this.orientation = orientation;\n    }\n}\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/Card.java b/src/main/java/it/polimi/ingsw/model/Card.java
--- a/src/main/java/it/polimi/ingsw/model/Card.java	(revision 044f0df272e71ce727f5c92f6c619c0dd6e15752)
+++ b/src/main/java/it/polimi/ingsw/model/Card.java	(date 1711303382379)
@@ -1,5 +1,7 @@
 package it.polimi.ingsw.model;
 
+import it.polimi.ingsw.model.enumerations.Orientation;
+
 public abstract class Card {
     private int id;
     public Orientation orientation;
Index: src/main/java/it/polimi/ingsw/model/BoardCellCoordinate.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\n\n/**\n * This class provide the needed mapping between the Coordinate-based\n * description of a given corner and its matrix-based (i.e. using indexes)\n * description.\n */\npublic class BoardCellCoordinate {\n    private int x;\n    private int y;\n\n    public BoardCellCoordinate(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void setX(int x) {\n        this.x = x;\n    }\n\n    public void setY(int y) {\n        this.y = y;\n    }\n\n    public void setXY(Coordinate coord) {\n        switch (coord) {\n            case NE:\n                this.setX(0);\n                this.setY(1);\n                break;\n            case SE:\n                this.setX(1);\n                this.setY(1);\n                break;\n            case SW:\n                this.setX(1);\n                this.setY(0);\n                break;\n            case NW:\n                this.setX(0);\n                this.setY(0);\n                break;\n        }\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public int getY() {\n        return y;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/BoardCellCoordinate.java b/src/main/java/it/polimi/ingsw/model/BoardCellCoordinate.java
--- a/src/main/java/it/polimi/ingsw/model/BoardCellCoordinate.java	(revision 044f0df272e71ce727f5c92f6c619c0dd6e15752)
+++ b/src/main/java/it/polimi/ingsw/model/BoardCellCoordinate.java	(date 1711303382383)
@@ -1,5 +1,7 @@
 package it.polimi.ingsw.model;
 
+import it.polimi.ingsw.model.enumerations.Coordinate;
+
 /**
  * This class provide the needed mapping between the Coordinate-based
  * description of a given corner and its matrix-based (i.e. using indexes)
Index: src/main/java/it/polimi/ingsw/model/Game.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\n\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.LinkedList;\n\npublic class Game {\n    private Queue<Player> player_queue;\n    private Player[] players;\n    private int num_players;\n    private Player first_player;\n    private boolean game_over;\n    private boolean last_turn;\n    private CommonBoard common_board;\n    private ConcreteDeck resource_deck;\n    private ConcreteDeck gold_deck;\n    private ConcreteDeck objective_deck;\n\n\n    public Game(CommonBoard common_board, Player[] players) {\n        player_queue = new LinkedList<>();\n        this.players = players;\n        this.first_player = players[0];\n        this.num_players = players.length-1;\n        this.game_over = false;\n        this.last_turn = false;\n        this.common_board = common_board; //initializes the board\n        this.resource_deck = common_board.getResourseConcreteDeck();\n        this.gold_deck = common_board.getGoldConcreteDeck();\n        this.objective_deck = common_board.getObjectiveConcreteDeck();\n    }\n\n    public void gameFlow(){\n        initializeGame();\n        while (!isGameOver()) {\n            while (!isLastTurn()) {\n                // Loop through players and handle each player's turn\n                for (Player player : player_queue) {\n                    placeCard(player.getChosenGameCard()); //TODO: da capire quale placeCard usare tra i 4 delle coordinate\n                    PersonalBoard current_board = player.getPersonalBoard();\n                    int delta = current_board.getDeltaPoints();\n                    common_board.movePlayer(player.getId(), delta);\n                    drawCard(); //TODO: pesco da terra o dal mazzo a seconda di cosa sceglie l'utente\n                    if(common_board.getPartialWinner() != -1)\n                        last_turn = true;\n                }\n            }\n            secondLastTurn();\n        }\n        calculateFinalScores();\n    }\n\n    public void initializeGame(){\n        common_board.initializeBoard();\n        dealCards();\n        fillQueue(player_queue, players);\n    }\n\n\n    public void dealCards() {\n        // Deal cards to players\n        for (Player player : player_queue) {\n            // Deal 2 cards from the resource deck\n            for (int i = 0; i < 2; i++) {\n                if (!resource_deck.isEmpty()) {\n                    Card card = resource_deck.pop(); // Remove the top card from the resource deck\n                    player.addToHand(card); // Add the card to the player's hand\n                }\n            }\n\n            // Deal 1 card from the gold deck\n            if (!gold_deck.isEmpty()) {\n                Card card = gold_deck.pop(); // Remove the top card from the gold deck\n                player.addToHand(card); // Add the card to the player's hand\n            }\n\n            for (int i = 0; i < 2; i++) {\n                if (!objective_deck.isEmpty()) {\n                    ObjectiveCard card1 = (ObjectiveCard)objective_deck.pop();\n                    ObjectiveCard card2 = (ObjectiveCard)objective_deck.pop();\n                    player.setSecretObjectives(card1, card2);\n                }\n            }\n        }\n    }\n\n\n    public void fillQueue(Queue<Player> player_queue, Player[] players){\n        if ( players== null || player_queue == null) {\n            throw new IllegalArgumentException(\"Array o coda nulli non sono ammessi.\");\n        }\n        for (Player element : players) {\n            player_queue.add(element);\n        }\n    }\n\n\n    public void calculateFinalScores() {\n        // Calculate final scores\n        //Riceve da commonBoard le posizioni dell'ultimo giro + da personalBoard i punteggi degli obiettivi, per ciascun giocatore\n        //somma per ogni giocatore\n    }\n\n    public void placeCard(Card card_chosen) {\n\n    }\n\n    public void drawCard(){\n       //da capire come usare pesca da mazzo o dal banco (metodi giÃ  scritti in CommonBoard)\n    }\n\n\n\n    public boolean isLastTurn() {\n        return last_turn;\n    }\n\n    public void lastTurn(){\n        for (int i = 0; i < num_players; i++) {\n            Player currentPlayer = player_queue.poll();\n            //il giocatore gioca\n            player_queue.offer(currentPlayer); // Rimetti il giocatore corrente in fondo alla coda\n        }\n        game_over = true;\n    }\n\n    public void secondLastTurn(){\n        for (int i = common_board.getPartialWinner(); i < num_players; i++) {\n            Player currentPlayer = player_queue.poll();\n            //il giocatore gioca\n            player_queue.offer(currentPlayer); // Rimetti il giocatore corrente in fondo alla coda\n        }\n        lastTurn();\n    }\n\n    public boolean isGameOver() {\n        return game_over;\n    }\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/Game.java b/src/main/java/it/polimi/ingsw/model/Game.java
--- a/src/main/java/it/polimi/ingsw/model/Game.java	(revision 044f0df272e71ce727f5c92f6c619c0dd6e15752)
+++ b/src/main/java/it/polimi/ingsw/model/Game.java	(date 1711306312738)
@@ -1,33 +1,37 @@
 package it.polimi.ingsw.model;
 
-import java.util.List;
-import java.util.Queue;
-import java.util.LinkedList;
+import java.util.*;
 
 public class Game {
     private Queue<Player> player_queue;
     private Player[] players;
     private int num_players;
-    private Player first_player;
     private boolean game_over;
     private boolean last_turn;
     private CommonBoard common_board;
     private ConcreteDeck resource_deck;
     private ConcreteDeck gold_deck;
     private ConcreteDeck objective_deck;
+    private int[] final_scores;
+    private Player winner;
+    private Player temp_winner;
 
 
     public Game(CommonBoard common_board, Player[] players) {
-        player_queue = new LinkedList<>();
+        this.player_queue = new LinkedList<>();
         this.players = players;
-        this.first_player = players[0];
-        this.num_players = players.length-1;
+        this.num_players = players.length;
         this.game_over = false;
         this.last_turn = false;
-        this.common_board = common_board; //initializes the board
-        this.resource_deck = common_board.getResourseConcreteDeck();
+        this.final_scores = new int[num_players];
+        this.common_board = common_board;
+        this.resource_deck = common_board.getResourceConcreteDeck();
         this.gold_deck = common_board.getGoldConcreteDeck();
         this.objective_deck = common_board.getObjectiveConcreteDeck();
+        // Aggiunta dei giocatori alla coda dei giocatori
+        for (Player player : players) {
+            this.player_queue.offer(player);
+        }
     }
 
     public void gameFlow(){
@@ -48,12 +52,12 @@
             secondLastTurn();
         }
         calculateFinalScores();
+        setWinner();
     }
 
     public void initializeGame(){
         common_board.initializeBoard();
         dealCards();
-        fillQueue(player_queue, players);
     }
 
 
@@ -85,20 +89,9 @@
     }
 
 
-    public void fillQueue(Queue<Player> player_queue, Player[] players){
-        if ( players== null || player_queue == null) {
-            throw new IllegalArgumentException("Array o coda nulli non sono ammessi.");
-        }
-        for (Player element : players) {
-            player_queue.add(element);
-        }
-    }
-
-
     public void calculateFinalScores() {
-        // Calculate final scores
-        //Riceve da commonBoard le posizioni dell'ultimo giro + da personalBoard i punteggi degli obiettivi, per ciascun giocatore
-        //somma per ogni giocatore
+        for(int i= 0; i<players.length - 1; i++)
+            final_scores[i] = players[i].getPersonalBoard().getPoints();
     }
 
     public void placeCard(Card card_chosen) {
@@ -109,8 +102,6 @@
        //da capire come usare pesca da mazzo o dal banco (metodi giÃ  scritti in CommonBoard)
     }
 
-
-
     public boolean isLastTurn() {
         return last_turn;
     }
@@ -136,5 +127,23 @@
     public boolean isGameOver() {
         return game_over;
     }
+
+
+    public Player getWinner(){
+        return winner;
+    }
+
+    public void setWinner(){
+        int temp_score = 0;
+        temp_winner = players[0];
+
+        for(int i= 0; i<players.length - 1; i++)
+            if (final_scores[i] > temp_score) {
+                temp_score = final_scores[i];
+                temp_winner = players[i];
+            }
+        this.winner = temp_winner;
+    }
+
 }
 
Index: src/main/java/it/polimi/ingsw/model/CommonBoard.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Stack;\n\n//NB il giocatore iniziale (pedina nera) Ã¨ il giocatore 0\n\npublic class CommonBoard {\n    private ConcreteDeck resource_concrete_deck; // resource_concrete_deck\n    private ConcreteDeck gold_concrete_deck; // gold_concrete_deck\n    private ConcreteDeck objective_concrete_deck; // objective_concrete_deck\n    private ConcreteDeck[] decks;\n    private CommonBoardNode[] board_nodes; // Array of nodes representing the board\n    private Card[][] table_cards; // Cards on the table\n    private int partial_winner = -1;;\n\n\n    public CommonBoard(CardsCollection resource_cards_collection,\n                       CardsCollection gold_cards_collection,\n                       CardsCollection objective_cards_collection,\n                       String resource_path, String gold_path, String objective_path,\n                       String resource_type, String gold_type, String objective_type) {\n        resource_concrete_deck = new ConcreteDeck(resource_cards_collection, resource_path, resource_type); //resource_concrete_deck\n        gold_concrete_deck = new ConcreteDeck(gold_cards_collection, gold_path, gold_type); //gold_concrete_deck\n        objective_concrete_deck = new ConcreteDeck(objective_cards_collection, objective_path, objective_type); //objective_concrete_deck\n        board_nodes = new CommonBoardNode[29];\n        decks = new ConcreteDeck[3]; // Create an array to hold the two decks\n        table_cards = new Card[3][2];\n\n    }\n     public ConcreteDeck getResourseConcreteDeck(){return resource_concrete_deck;}\n     public ConcreteDeck getGoldConcreteDeck(){return gold_concrete_deck;}\n     public ConcreteDeck getObjectiveConcreteDeck(){return objective_concrete_deck;}\n\n    // Method to initialize the board\n    public void initializeBoard() {\n        for (int i = 0; i < 29; i++) {\n            board_nodes[i] = new CommonBoardNode(i);\n        }\n        // Populate the table with cards from the decks\n        for (int i = 0; i < 2; i++) {\n            // Populate the first array with two cards from the Resource ConcreteDeck\n            Card cardFromConcreteDeck1 = resource_concrete_deck.pop();\n            table_cards[0][i] = cardFromConcreteDeck1;\n\n            // Populate the second array with two cards from the Gold ConcreteDeck\n            Card cardFromConcreteDeck2 = gold_concrete_deck.pop();\n            table_cards[1][i] = cardFromConcreteDeck2;\n\n            // Populate the second array with two cards from the Objective ConcreteDeck\n            Card cardFromConcreteDeck3 = objective_concrete_deck.pop();\n            table_cards[2][i] = cardFromConcreteDeck3;\n        }\n        decks[0] = resource_concrete_deck;\n        decks[1] = gold_concrete_deck;\n        decks[2] = objective_concrete_deck;\n    }\n\n\n    // Method to draw a card directly from a ConcreteDeck\n    public Card drawFromConcreteDeck(int ConcreteDeckIndex) {\n        if (ConcreteDeckIndex >= 0 && ConcreteDeckIndex < 2) {\n            return decks[ConcreteDeckIndex].pop(); //the return of this function is the card that will be taken by the player\n        }\n        return null;\n    }\n\n\n    // Method to draw a card from the table and replace it with a card from the corresponding ConcreteDeck\n    public Card drawFromTable(int row, int col, int ConcreteDeckIndex) {\n        if (row >= 0 && row < 2 && col >= 0 && col < 2 && ConcreteDeckIndex >= 0 && ConcreteDeckIndex < 2) {\n            // Remove the card from the table and store it\n            Card drawnCard = table_cards[row][col];\n            // Draw a card from the corresponding ConcreteDeck and replace it on the table\n            table_cards[row][col] = decks[ConcreteDeckIndex].pop();\n            // Return the drawn card\n            return drawnCard;\n        }\n        return null;\n    }\n\n    // Method to get the position of a player\n    private int getPlayerPosition(int player_index) {\n        for (CommonBoardNode node : board_nodes) {\n            if (node.isPlayerPresent(player_index)) {\n                return node.getNodeNumber();\n            }\n        }\n        return -1; // Player not found\n    }\n\n\n\n    // Method to move a player by a specified delta\n    public void movePlayer(int playerIndex, int delta) {\n        // Get the current position of the player\n        int current_position = getPlayerPosition(playerIndex);\n\n        // Calculate the new position by adding delta\n        int new_position = current_position + delta;\n\n        // Check if the new position is within the board bounds\n        if (new_position >= 0 && new_position < 29) {\n            // Remove the player from the current position\n            board_nodes[current_position].setPlayer(playerIndex, false);\n            // Set the player to the new position\n            board_nodes[new_position].setPlayer(playerIndex, true);\n        }\n\n        // Check if a player reaches 20 points for the first time\n        if (getPlayerPosition(playerIndex) >= 20 && partial_winner == -1) {\n            setPartialWinner(playerIndex);\n        }\n\n    }\n\n    public int getPartialWinner(){\n        return partial_winner;\n    }\n\n    // Method to set a player as partial winner\n    public void setPartialWinner(int playerIndex) {\n        this.partial_winner = playerIndex;\n    }\n\n}\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/CommonBoard.java b/src/main/java/it/polimi/ingsw/model/CommonBoard.java
--- a/src/main/java/it/polimi/ingsw/model/CommonBoard.java	(revision 044f0df272e71ce727f5c92f6c619c0dd6e15752)
+++ b/src/main/java/it/polimi/ingsw/model/CommonBoard.java	(date 1711306312742)
@@ -28,7 +28,7 @@
         table_cards = new Card[3][2];
 
     }
-     public ConcreteDeck getResourseConcreteDeck(){return resource_concrete_deck;}
+     public ConcreteDeck getResourceConcreteDeck(){return resource_concrete_deck;}
      public ConcreteDeck getGoldConcreteDeck(){return gold_concrete_deck;}
      public ConcreteDeck getObjectiveConcreteDeck(){return objective_concrete_deck;}
 
Index: src/main/java/it/polimi/ingsw/model/ObjectiveFactory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\n\npublic class ObjectiveFactory {\n\n            public ObjectiveCard createObjectiveCard(String type, int id, Orientation orientation,int points) {\n                switch (type) {\n                    case \"Item\":\n                        return new ItemObjectiveCard(id, orientation,points);\n                    case \"LetterPattern\":\n                        return new LetterPatternObjectiveCard(id, orientation, points);\n                    case \"DiagonalPattern\":\n                        return new DiagonalPatternObjectiveCard(id, orientation, points);\n                    case \"Resource\":\n                        return new ResourceObjectiveCard(id, orientation, points);\n                    default:\n                        throw new IllegalArgumentException(\"Invalid objective card type: \" + type);\n                }\n            }\n        }\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/ObjectiveFactory.java b/src/main/java/it/polimi/ingsw/model/ObjectiveFactory.java
--- a/src/main/java/it/polimi/ingsw/model/ObjectiveFactory.java	(revision 044f0df272e71ce727f5c92f6c619c0dd6e15752)
+++ b/src/main/java/it/polimi/ingsw/model/ObjectiveFactory.java	(date 1711304364880)
@@ -1,19 +1,29 @@
 package it.polimi.ingsw.model;
 
+import it.polimi.ingsw.model.enumerations.Orientation;
+
 public class ObjectiveFactory {
-
-            public ObjectiveCard createObjectiveCard(String type, int id, Orientation orientation,int points) {
-                switch (type) {
-                    case "Item":
-                        return new ItemObjectiveCard(id, orientation,points);
-                    case "LetterPattern":
-                        return new LetterPatternObjectiveCard(id, orientation, points);
-                    case "DiagonalPattern":
-                        return new DiagonalPatternObjectiveCard(id, orientation, points);
-                    case "Resource":
-                        return new ResourceObjectiveCard(id, orientation, points);
-                    default:
-                        throw new IllegalArgumentException("Invalid objective card type: " + type);
-                }
-            }
-        }
+    /**
+     * Metodo per creare un oggetto ObjectiveCard in base al tipo specificato
+     * @param type il tipo di obiettivo da creare
+     * @param id l'id della carta
+     * @param orientation l'orientamento dell'obiettivo
+     * @param points il punteggio dell'obiettivo
+     * @return l'oggetto ObjectiveCard creato
+     * @throws IllegalArgumentException se il tipo di obiettivo specificato non Ã¨ valido
+     */
+    public static ObjectiveCard createObjectiveCard(String type, int id, Orientation orientation, int points) {
+        switch (type) {
+            case "Item":
+                return new ItemObjectiveCard(id, orientation, points);
+            case "LetterPattern":
+                return new LetterPatternObjectiveCard(id, orientation, points);
+            case "DiagonalPattern":
+                return new DiagonalPatternObjectiveCard(id, orientation, points);
+            case "Resource":
+                return new ResourceObjectiveCard(id, orientation, points);
+            default:
+                throw new IllegalArgumentException("Invalid objective card type: " + type);
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/it/polimi/ingsw/model/Orientation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/Orientation.java b/src/main/java/it/polimi/ingsw/model/enumerations/Orientation.java
rename from src/main/java/it/polimi/ingsw/model/Orientation.java
rename to src/main/java/it/polimi/ingsw/model/enumerations/Orientation.java
--- a/src/main/java/it/polimi/ingsw/model/Orientation.java	(revision 044f0df272e71ce727f5c92f6c619c0dd6e15752)
+++ b/src/main/java/it/polimi/ingsw/model/enumerations/Orientation.java	(date 1711303382372)
@@ -1,4 +1,4 @@
-package it.polimi.ingsw.model;
+package it.polimi.ingsw.model.enumerations;
 
 public enum Orientation {
     FRONT,
Index: src/main/java/it/polimi/ingsw/model/LetterPatternObjectiveCard.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\n\n/**\n * The following class describe those objective cards that deal\n * with ** letter ** pattern recognition of cards with respect to the board configuration:\n * There are 4 possible (geometric) patterns of three cards each. In order to distinguish\n * the cards in the patter to recognise, we only need to know the color of each. It is useful\n * to implements some methods that can achieve our goals in terms of sub-matrices encoding.\n */\npublic class LetterPatternObjectiveCard extends ObjectiveCard {\n\n    /**\n     * This attributes let us use all the methods we\n     * implemented in Personal board. Dim = 5 x 3;\n     */\n    public PersonalBoard aux_personal_board;\n    public ScoreStrategy score_strategy;\n\n    /**\n     * @param id\n     * @param orientation\n     */\n    public LetterPatternObjectiveCard(int id, Orientation orientation, int points) {\n        super(id, orientation, points);\n        this.aux_personal_board = new PersonalBoard(5, 3);\n        this.score_strategy = new LetterPatternScoreStrategy();\n    }\n\n    /**\n     * This method is an initializer; in fact we initialize auxiliary\n     * cards that are out of the deck. In general their id does not make\n     * any sense. For the sake of simplicity, we assume that those cards\n     * have id set to -1;\n     *\n     * Remark: color is not a parameter anymore.\n     *\n     * @requires\n     *      color == RED || color == BLUE\n     */\n    public void init_obj_L() {\n\n        ResourceCard card1 = new ResourceCard(-1, Orientation.FRONT, Color.RED);\n        ResourceCard card2 = new ResourceCard(-1, Orientation.FRONT, Color.RED);\n        ResourceCard card3 = new ResourceCard(-1, Orientation.FRONT, Color.GREEN);\n\n        aux_personal_board.bruteForcePlaceCardSE(card1, 0, 0);\n        aux_personal_board.bruteForcePlaceCardSE(card3, 3, 1);\n        aux_personal_board.placeCardAtNO(card3, card2);\n    }\n\n    public void init_obj_J() {\n\n        ResourceCard card1 = new ResourceCard(-1, Orientation.FRONT, Color.GREEN);\n        ResourceCard card2 = new ResourceCard(-1, Orientation.FRONT, Color.GREEN);\n        ResourceCard card3 = new ResourceCard(-1, Orientation.FRONT, Color.PURPLE);\n\n        aux_personal_board.bruteForcePlaceCardSE(card1, 0, 1);\n        aux_personal_board.bruteForcePlaceCardSE(card3, 3, 0);\n        aux_personal_board.placeCardAtNE(card3, card2);\n    }\n\n    public void init_obj_p() {\n\n        ResourceCard card1 = new ResourceCard(-1, Orientation.FRONT, Color.RED);\n        ResourceCard card2 = new ResourceCard(-1, Orientation.FRONT, Color.BLUE);\n        ResourceCard card3 = new ResourceCard(-1, Orientation.FRONT, Color.BLUE);\n\n        aux_personal_board.bruteForcePlaceCardSE(card1, 0, 1);\n        aux_personal_board.bruteForcePlaceCardSE(card3, 3, 0);\n        aux_personal_board.placeCardAtSO(card1, card2);\n    }\n\n    public void init_obj_q() {\n\n        ResourceCard card1 = new ResourceCard(-1, Orientation.FRONT, Color.BLUE);\n        ResourceCard card2 = new ResourceCard(-1, Orientation.FRONT, Color.PURPLE);\n        ResourceCard card3 = new ResourceCard(-1, Orientation.FRONT, Color.PURPLE);\n\n        aux_personal_board.bruteForcePlaceCardSE(card1, 0, 0);\n        aux_personal_board.bruteForcePlaceCardSE(card3, 3, 1);\n        aux_personal_board.placeCardAtSE(card1, card2);\n    }\n\n    @Override\n    public int calculateScore(PersonalBoard personal_board) {\n        return score_strategy.calculateScore(this, personal_board);\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/LetterPatternObjectiveCard.java b/src/main/java/it/polimi/ingsw/model/LetterPatternObjectiveCard.java
--- a/src/main/java/it/polimi/ingsw/model/LetterPatternObjectiveCard.java	(revision 044f0df272e71ce727f5c92f6c619c0dd6e15752)
+++ b/src/main/java/it/polimi/ingsw/model/LetterPatternObjectiveCard.java	(date 1711303382366)
@@ -1,5 +1,8 @@
 package it.polimi.ingsw.model;
 
+import it.polimi.ingsw.model.enumerations.Color;
+import it.polimi.ingsw.model.enumerations.Orientation;
+
 /**
  * The following class describe those objective cards that deal
  * with ** letter ** pattern recognition of cards with respect to the board configuration:
Index: src/test/java/it/polimi/ingsw/model/PersonalBoardTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class PersonalBoardTest {\n    private PersonalBoard personalBoard;\n\n    @BeforeEach\n    public void setup() {\n        personalBoard = new PersonalBoard();\n    }\n\n    @Test\n    public void testUpdateMushrooms() {\n        personalBoard.updateMushrooms(5);\n        assertEquals(5, personalBoard.getNum_mushrooms());\n    }\n\n    @Test\n    public void testUpdateLeaves() {\n        personalBoard.updateLeaves(3);\n        assertEquals(3, personalBoard.getNum_leaves());\n    }\n\n    @Test\n    void testBruteForcePlaceCardSE() {\n\n        ResourceCard card = new ResourceCard(1, Orientation.FRONT, Color.BLUE); // You may need to provide appropriate arguments to the constructor\n        int i = 0; // Specify the row index\n        int j = 0; // Specify the column index\n\n        personalBoard.bruteForcePlaceCardSE(card, i, j);\n\n        for (int k = 0; k < 2; k++) {\n            for (int h = 0; h < 2; h++) {\n                assertTrue(personalBoard.board[i + k][j + h].is_full);\n            }\n        }\n    }\n\n    @Test\n    void testPlaceCardAtSE() {\n\n        ResourceCard card1 = new ResourceCard(1, Orientation.FRONT, Color.BLUE);\n        ResourceCard card2 = new ResourceCard(2, Orientation.FRONT, Color.RED);\n        int i = 0; // Specify the row index\n        int j = 0; // Specify the column index\n\n        personalBoard.bruteForcePlaceCardSE(card1, i, j);\n\n        try {\n            personalBoard.placeCardAtSE(card1, card2);\n        } catch (IllegalMoveException e) {\n            fail(\"Exception should not be thrown\");\n        }\n\n        for (int k = 0; k < 2; k++) {\n            for (int h = 0; h < 2; h++) {\n                assertTrue(personalBoard.board[i + k][j + h].is_full);\n            }\n        }\n    }\n\n    // Add more tests for other methods\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/it/polimi/ingsw/model/PersonalBoardTest.java b/src/test/java/it/polimi/ingsw/model/PersonalBoardTest.java
--- a/src/test/java/it/polimi/ingsw/model/PersonalBoardTest.java	(revision 044f0df272e71ce727f5c92f6c619c0dd6e15752)
+++ b/src/test/java/it/polimi/ingsw/model/PersonalBoardTest.java	(date 1711303382397)
@@ -1,5 +1,8 @@
 package it.polimi.ingsw.model;
 
+import it.polimi.ingsw.model.enumerations.Color;
+import it.polimi.ingsw.model.enumerations.Orientation;
+import it.polimi.ingsw.model.exceptions.IllegalMoveException;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import static org.junit.jupiter.api.Assertions.*;
Index: src/main/java/it/polimi/ingsw/model/CardsCollection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Optional;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Iterator;\n\n\npublic  class CardsCollection {\n    public List<Card> cards;\n\n    public CardsCollection() {\n        cards = new ArrayList<>();\n    }\n\n    public void addCard(Card card) {\n        cards.add(card);\n    }\n\n    public int size() {\n        return cards.size();\n    }\n\n    /**\n     * To do: populateDeck read a .json file and populate the data structure using\n     * the constructors and the setters of Card subclasses.\n     */\n    // In this case we are creating only the FRONT, but we need also the back of the card.\n    public void populateDeck(String jsonFilePath, String type) {\n        ObjectMapper objectMapper = new ObjectMapper();\n        try {\n            JsonNode rootNode = objectMapper.readTree(new File(jsonFilePath));\n            JsonNode cardsNode = rootNode.path(\"cards\");\n\n            for (JsonNode cardNode : cardsNode) {\n\n                int id = cardNode.path(\"id\").asInt();\n                String colorStr = cardNode.path(\"color\").asText();\n                Color color = Color.valueOf(colorStr.toUpperCase());\n                Orientation orientation = Orientation.FRONT;\n                int score = cardNode.path(\"points\").asInt();\n\n                // This is the case where we have to create a ResourceCard.\n                // NE corner.\n                Corner[][] actual_corners = new Corner[2][2];\n                String NE_corner_content = cardNode.path(\"NE\").asText();\n                if (NE_corner_content.equals(\"NonVisible\")) {\n                    actual_corners[0][1].is_visible = false;\n                } else {\n                        actual_corners[0][1].setCornerResource(Resource.valueOf(NE_corner_content.toUpperCase()));\n                }\n                // SE Corner.\n                String SE_corner_content = cardNode.path(\"SE\").asText();\n                if (SE_corner_content.equals(\"NonVisible\")) {\n                    actual_corners[1][0].is_visible = false;\n                } else {\n                        actual_corners[1][0].setCornerResource(Resource.valueOf(SE_corner_content.toUpperCase()));\n                }\n                // NO corner.\n                String NO_corner_content = cardNode.path(\"NO\").asText();\n                if (NO_corner_content.equals(\"NonVisible\")) {\n                    actual_corners[0][1].is_visible = false;\n                } else {\n                        actual_corners[0][1].setCornerResource(Resource.valueOf(NO_corner_content.toUpperCase()));\n                }\n                // SO corner.\n                String SO_corner_content = cardNode.path(\"SO\").asText();\n                if (SO_corner_content.equals(\"NonVisible\")) {\n                    actual_corners[1][1].is_visible = false;\n                } else {\n                        actual_corners[1][1].setCornerResource(Resource.valueOf(SO_corner_content.toUpperCase()));\n                }\n\n                if (cardNode.path(\"type\").asText().equals(\"Resource\") && type.equals(\"Resource\")){\n                    ResourceCard card = new ResourceCard(id, orientation, color, score, actual_corners);\n                    // Qui potresti settare ulteriori proprietÃ  specifiche per ResourceCard\n                    this.addCard(card);\n                }\n\n                if (cardNode.path(\"type\").asText().equals(\"Gold\") && type.equals(\"Gold\")){\n                    int MushroomRequired = cardNode.path(\"MushroomRequired\").asInt();\n                    int ButterflyRequired = cardNode.path(\"ButterflyRequired\").asInt();\n                    int WolfRequired = cardNode.path(\"WolfRequired\").asInt();\n                    int LeafRequired = cardNode.path(\"LeafRequired\").asInt();\n\n                    // Item_for_score\n                    int PotionCount = cardNode.path(\"PotionCount\").asInt();\n                    int FeatherCount = cardNode.path(\"FeatherCount\").asInt();\n                    int ParchmentCount = cardNode.path(\"ParchmentCount\").asInt();\n                    int CoverCorners = cardNode.path(\"CoverCorners\").asInt();\n\n                    // Problem: Item optional!\n                    Optional<Item> item_for_score = Optional.empty();\n                    if (PotionCount == 1) {\n                        item_for_score = Optional.of(Item.POTION);\n                    }\n                    if (FeatherCount == 1) {\n                        item_for_score = Optional.of(Item.FEATHER);\n                    }\n                    if (ParchmentCount == 1) {\n                        item_for_score = Optional.of(Item.PARCHMENT);\n                    }\n\n                    GoldCard gold_card = new GoldCard(id, orientation, color);\n                    gold_card.setGoldCard(item_for_score, CoverCorners, MushroomRequired, LeafRequired, ButterflyRequired, WolfRequired);\n                    this.addCard(gold_card);\n                }\n            }\n            System.out.println(\"Deck populated successfully.\");\n        } catch (Exception e) {\n            System.err.println(\"Error populating deck: \" + e.getMessage());\n        }\n    }\n\n    // populate objective cards draft\n    public void populateDeckObjective(String jsonFilePath) {\n        ObjectMapper objectMapper = new ObjectMapper();\n        try {\n            JsonNode rootNode = objectMapper.readTree(new File(jsonFilePath));\n            JsonNode cardsNode = rootNode.path(\"cards\");\n\n            for (JsonNode cardNode : cardsNode) {\n\n                int id = cardNode.path(\"id\").asInt();\n                Orientation orientation = Orientation.FRONT;\n                int points = cardNode.path(\"points\").asInt();\n                String pattern = cardNode.path(\"pattern\").asText();\n                if (pattern.equals(\"L\")) {\n                    LetterPatternObjectiveCard card = new LetterPatternObjectiveCard(id, orientation, points);\n                    card.init_obj_L();\n                    // come si implementa?? come si collegano??\n                    this.addCard(card);\n                }\n                if (pattern.equals(\"J\")) {\n                    LetterPatternObjectiveCard card = new LetterPatternObjectiveCard(id, orientation, points);\n                    card.init_obj_J();\n                    this.addCard(card);\n                }\n                if (pattern.equals(\"P\")) {\n                    LetterPatternObjectiveCard card = new LetterPatternObjectiveCard(id, orientation, points);\n                    this.addCard(card);\n                }\n                if (pattern.equals(\"Q\")) {\n                    LetterPatternObjectiveCard card = new LetterPatternObjectiveCard(id, orientation, points);\n                    card.init_obj_q();\n                    this.addCard(card);\n                }\n                if (pattern.equals(\"increasingDiagonal\")) {\n                    DiagonalPatternObjectiveCard card = new DiagonalPatternObjectiveCard(id, orientation, points);\n                    String color = cardNode.path(\"color1\").asText();\n                    card.init_objIncreasingDiagonal(Color.valueOf(color.toUpperCase()));\n                    this.addCard(card);\n                }\n                if (pattern.equals(\"decreasingDiagonal\")) {\n                    DiagonalPatternObjectiveCard card = new DiagonalPatternObjectiveCard(id, orientation, points);\n                    String color = cardNode.path(\"color1\").asText();\n                    card.init_objDecreasingDiagonal(Color.valueOf(color.toUpperCase()));\n                    this.addCard(card);\n                }\n                if (pattern== null) {\n                    // Completa quando le classi di objective sono finite.\n\n\n                }\n            }\n            System.out.println(\"Objective cards Deck populated successfully.\");\n        } catch (Exception e) {\n            System.err.println(\"Error populating objective cards deck: \" + e.getMessage());\n        }\n    }\n\n    // populate starter cards draft: it create the starter card collection, both front and back of the card. At the end\n    // we have a collections of starter cards, that has size X2.\n    public void populateDeckStarterFrontAndBack(String jsonFilePath) {\n        ObjectMapper objectMapper = new ObjectMapper();\n        try {\n            JsonNode rootNode = objectMapper.readTree(new File(jsonFilePath));\n            JsonNode cardsNode = rootNode.path(\"cards\");\n\n            for (JsonNode cardNode : cardsNode) {\n                int id = cardNode.path(\"id\").asInt();\n                String permanent_resource1 = cardNode.path(\"permanentResource1\").asText();\n                String permanent_resource2 = cardNode.path(\"permanentResource2\").asText();\n                String permanent_resource3 = cardNode.path(\"permanentResource3\").asText();\n                int front_visible_corner = cardNode.path(\"frontVisibleCorner\").asInt();\n                String front_NE= cardNode.path(\"frontNE\").asText();\n                String front_SE = cardNode.path(\"frontSE\").asText();\n                String front_NO = cardNode.path(\"frontNW\").asText();\n                String front_SO = cardNode.path(\"frontSW\").asText();\n                int back_visible_corner = cardNode.path(\"backVisibleCorner\").asInt();\n                String back_NE= cardNode.path(\"backNE\").asText();\n                String back_SE = cardNode.path(\"backSE\").asText();\n                String back_NO = cardNode.path(\"backNW\").asText();\n                String back_SO = cardNode.path(\"backSW\").asText();\n\n                StarterCard card_front = new StarterCard(id, Orientation.FRONT);\n                Corner[][] actual_corners_front = new Corner[2][2];\n                // Front of the Starter Card\n                if (front_NE.equals(\"NonVisible\")) {\n                    actual_corners_front[0][1].is_visible = false;\n                } else {\n                        actual_corners_front[0][1].setCornerResource(Resource.valueOf(front_NE.toUpperCase()));}\n                if (front_SE.equals(\"NonVisible\")) {\n                    actual_corners_front[1][0].is_visible = false;\n                } else {\n                    actual_corners_front[1][0].setCornerResource(Resource.valueOf(front_SE.toUpperCase()));}\n                if (front_NO.equals(\"NonVisible\")) {\n                    actual_corners_front[0][0].is_visible = false;\n                } else {\n                    actual_corners_front[0][0].setCornerResource(Resource.valueOf(front_NO.toUpperCase()));}\n                if (front_SO.equals(\"NonVisible\")) {\n                    actual_corners_front[1][1].is_visible = false;\n                } else {\n                    actual_corners_front[1][1].setCornerResource(Resource.valueOf(front_SO.toUpperCase()));}\n                // Back of the Starter Card\n                StarterCard card_back = new StarterCard(id, Orientation.BACK);\n                Corner[][] actual_corners_back = new Corner[2][2];\n\n                if (back_NE.equals(\"NonVisible\")) {\n                    actual_corners_back[0][1].is_visible = false;\n                } else {\n                    actual_corners_back[0][1].setCornerResource(Resource.valueOf(back_NE.toUpperCase()));}\n                if (back_SE.equals(\"NonVisible\")) {\n                    actual_corners_back[1][0].is_visible = false;\n                } else {\n                    actual_corners_back[1][0].setCornerResource(Resource.valueOf(back_SE.toUpperCase()));}\n                if (back_NO.equals(\"NonVisible\")) {\n                    actual_corners_back[0][0].is_visible = false;\n                } else {\n                    actual_corners_back[0][0].setCornerResource(Resource.valueOf(back_NO.toUpperCase()));}\n                if (back_SO.equals(\"NonVisible\")) {\n                    actual_corners_back[1][1].is_visible = false;\n                } else {\n                    actual_corners_back[1][1].setCornerResource(Resource.valueOf(back_SO.toUpperCase()));}\n\n                // Remark: read carefully the Starter Card class. Here we create at the same moment two cards: the first that is the front, and the second one is the back of the same card.\n                // But they are two different objects, they have in common the same id!\n\n                card_front.SetStarterCardFront(Resource.valueOf(permanent_resource1.toUpperCase()), Resource.valueOf(permanent_resource2.toUpperCase()), Resource.valueOf(permanent_resource3.toUpperCase()), actual_corners_front);\n                card_back.setStarterCardBack(actual_corners_back);\n            }\n            System.out.println(\"Starter cards Deck populated successfully.\");\n        } catch (Exception e) {\n            System.err.println(\"Error populating starter cards deck: \" + e.getMessage());\n        }\n\n    }\n\n\n\n    }\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/CardsCollection.java b/src/main/java/it/polimi/ingsw/model/CardsCollection.java
--- a/src/main/java/it/polimi/ingsw/model/CardsCollection.java	(revision 044f0df272e71ce727f5c92f6c619c0dd6e15752)
+++ b/src/main/java/it/polimi/ingsw/model/CardsCollection.java	(date 1711303382395)
@@ -1,14 +1,16 @@
 package it.polimi.ingsw.model;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.Optional;
 import com.fasterxml.jackson.databind.JsonNode;
 import com.fasterxml.jackson.databind.ObjectMapper;
+import it.polimi.ingsw.model.enumerations.Color;
+import it.polimi.ingsw.model.enumerations.Item;
+import it.polimi.ingsw.model.enumerations.Orientation;
+import it.polimi.ingsw.model.enumerations.Resource;
+
 import java.io.File;
-import java.io.IOException;
-import java.util.Iterator;
 
 
 public  class CardsCollection {
Index: src/main/java/it/polimi/ingsw/model/Coordinate.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/Coordinate.java b/src/main/java/it/polimi/ingsw/model/enumerations/Coordinate.java
rename from src/main/java/it/polimi/ingsw/model/Coordinate.java
rename to src/main/java/it/polimi/ingsw/model/enumerations/Coordinate.java
--- a/src/main/java/it/polimi/ingsw/model/Coordinate.java	(revision 044f0df272e71ce727f5c92f6c619c0dd6e15752)
+++ b/src/main/java/it/polimi/ingsw/model/enumerations/Coordinate.java	(date 1711303382403)
@@ -1,4 +1,4 @@
-package it.polimi.ingsw.model;
+package it.polimi.ingsw.model.enumerations;
 
 public enum Coordinate {
     NE,
Index: src/main/java/it/polimi/ingsw/model/Resource.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/Resource.java b/src/main/java/it/polimi/ingsw/model/enumerations/Resource.java
rename from src/main/java/it/polimi/ingsw/model/Resource.java
rename to src/main/java/it/polimi/ingsw/model/enumerations/Resource.java
--- a/src/main/java/it/polimi/ingsw/model/Resource.java	(revision 044f0df272e71ce727f5c92f6c619c0dd6e15752)
+++ b/src/main/java/it/polimi/ingsw/model/enumerations/Resource.java	(date 1711303382385)
@@ -1,4 +1,4 @@
-package it.polimi.ingsw.model;
+package it.polimi.ingsw.model.enumerations;
 
 public enum Resource {
     LEAF,
Index: src/main/java/it/polimi/ingsw/model/ResourceCard.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\n\npublic class ResourceCard extends Card {\n\n    // TODO: you always have to consider the orientation of the card...\n    private int score;\n    public Color color;\n    private Corner[][] corners;\n\n    /**\n     *\n     * @param id\n     * @param orientation\n     * @param color\n     */\n    public ResourceCard(int id, Orientation orientation, Color color) {\n        super(id, orientation);\n        this.score = 0;\n\n        this.corners = new Corner[2][2];\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++) {\n                corners[i][j] = new Corner(new BoardCellCoordinate(i, j));\n            }\n        }\n\n        this.color = color;\n    }\n\n    /**\n     * Second constructor to initialize the cards and the respective corners. We do not need a setter method at the moment.\n     * @param score\n     * @param actual_corners\n     */\n    public ResourceCard(int id, Orientation orientation, Color color,int score , Corner[][] actual_corners) {\n        super(id, orientation);\n        this.score = score;\n\n        this.corners = new Corner[2][2];\n        for (int i = 0; i < 2; i++) {\n            for(int j = 0; j < 2; j++) {\n                this.corners[i][j] = actual_corners[i][j];\n            }\n        }\n    }\n\n    /**\n     *\n     * @return NE corner\n     */\n    public Corner getCornerAtNE () {\n        return corners[0][1];\n    }\n\n    /**\n     *\n     * @return SE corner\n     */\n    public Corner getCornerAtSE () {\n        return corners[1][1];\n    }\n\n    /**\n     *\n     * @return SO corner\n     */\n    public Corner getCornerAtSO () {\n        return corners[1][0];\n    }\n\n    /**\n     *\n     * @return NO corner\n     */\n    public Corner getCornerAtNO () {\n        return corners[0][0];\n    }\n\n    /**\n     * @requires\n     *      0 <= i < 2 && 0 <= j < 2;\n     * @param i\n     * @param j\n     * @return the corner indexed by the couple (i, j)\n     */\n    public Corner getCornerAt(int i, int j) {\n        if (i == 0 && j == 0)\n            return this.getCornerAtNO();\n        else if (i == 0 && j == 1)\n            return this.getCornerAtNE();\n        else if (i == 1 && j == 0)\n            return this.getCornerAtSO();\n        else\n            return this.getCornerAtSE();\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/ResourceCard.java b/src/main/java/it/polimi/ingsw/model/ResourceCard.java
--- a/src/main/java/it/polimi/ingsw/model/ResourceCard.java	(revision 044f0df272e71ce727f5c92f6c619c0dd6e15752)
+++ b/src/main/java/it/polimi/ingsw/model/ResourceCard.java	(date 1711308180699)
@@ -1,5 +1,8 @@
 package it.polimi.ingsw.model;
 
+import it.polimi.ingsw.model.enumerations.Color;
+import it.polimi.ingsw.model.enumerations.Orientation;
+
 public class ResourceCard extends Card {
 
     // TODO: you always have to consider the orientation of the card...
@@ -64,7 +67,7 @@
      *
      * @return SO corner
      */
-    public Corner getCornerAtSO () {
+    public Corner getCornerAtSW () {
         return corners[1][0];
     }
 
@@ -72,7 +75,7 @@
      *
      * @return NO corner
      */
-    public Corner getCornerAtNO () {
+    public Corner getCornerAtNW () {
         return corners[0][0];
     }
 
@@ -85,11 +88,11 @@
      */
     public Corner getCornerAt(int i, int j) {
         if (i == 0 && j == 0)
-            return this.getCornerAtNO();
+            return this.getCornerAtNW();
         else if (i == 0 && j == 1)
             return this.getCornerAtNE();
         else if (i == 1 && j == 0)
-            return this.getCornerAtSO();
+            return this.getCornerAtSW();
         else
             return this.getCornerAtSE();
     }
Index: src/main/java/it/polimi/ingsw/model/ItemObjectiveCard.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\n\npublic class ItemObjectiveCard extends ObjectiveCard {\n\n\n    /**\n     * @param id\n     * @param orientation\n     */\n    public ItemObjectiveCard(int id, Orientation orientation, int points) {\n        super(id, orientation, points);\n    }\n\n    @Override\n    public int calculateScore(PersonalBoard personal_board) {\n        return personal_board.getNum_mushrooms() + personal_board.getNum_leaves();\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/ItemObjectiveCard.java b/src/main/java/it/polimi/ingsw/model/ItemObjectiveCard.java
--- a/src/main/java/it/polimi/ingsw/model/ItemObjectiveCard.java	(revision 044f0df272e71ce727f5c92f6c619c0dd6e15752)
+++ b/src/main/java/it/polimi/ingsw/model/ItemObjectiveCard.java	(date 1711303382405)
@@ -1,5 +1,7 @@
 package it.polimi.ingsw.model;
 
+import it.polimi.ingsw.model.enumerations.Orientation;
+
 public class ItemObjectiveCard extends ObjectiveCard {
 
 
Index: src/main/java/it/polimi/ingsw/model/Color.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/Color.java b/src/main/java/it/polimi/ingsw/model/enumerations/Color.java
rename from src/main/java/it/polimi/ingsw/model/Color.java
rename to src/main/java/it/polimi/ingsw/model/enumerations/Color.java
--- a/src/main/java/it/polimi/ingsw/model/Color.java	(revision 044f0df272e71ce727f5c92f6c619c0dd6e15752)
+++ b/src/main/java/it/polimi/ingsw/model/enumerations/Color.java	(date 1711303382399)
@@ -1,4 +1,4 @@
-package it.polimi.ingsw.model;
+package it.polimi.ingsw.model.enumerations;
 
 public enum Color {
     RED,
