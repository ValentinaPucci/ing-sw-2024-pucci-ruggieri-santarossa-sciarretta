Index: .idea/ing-sw-2024-pucci-santarossa-ruggieri-sciarretta.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<module type=\"JAVA_MODULE\" version=\"4\">\n  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n    <exclude-output />\n    <content url=\"file://$MODULE_DIR$\">\n      <sourceFolder url=\"file://$MODULE_DIR$\" isTestSource=\"false\" />\n    </content>\n    <orderEntry type=\"inheritedJdk\" />\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n    <orderEntry type=\"library\" name=\"fasterxml.jackson.core.annotations\" level=\"project\" />\n    <orderEntry type=\"library\" name=\"fasterxml.jackson.core.databind\" level=\"project\" />\n  </component>\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/ing-sw-2024-pucci-santarossa-ruggieri-sciarretta.iml b/.idea/ing-sw-2024-pucci-santarossa-ruggieri-sciarretta.iml
--- a/.idea/ing-sw-2024-pucci-santarossa-ruggieri-sciarretta.iml	(revision c480030d421db561c29453bbb71331faf3102cda)
+++ b/.idea/ing-sw-2024-pucci-santarossa-ruggieri-sciarretta.iml	(date 1711200104807)
@@ -1,13 +1,8 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <module type="JAVA_MODULE" version="4">
-  <component name="NewModuleRootManager" inherit-compiler-output="true">
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
+  <component name="AdditionalModuleElements">
+    <content url="file://$MODULE_DIR$" dumb="true">
       <sourceFolder url="file://$MODULE_DIR$" isTestSource="false" />
     </content>
-    <orderEntry type="inheritedJdk" />
-    <orderEntry type="sourceFolder" forTests="false" />
-    <orderEntry type="library" name="fasterxml.jackson.core.annotations" level="project" />
-    <orderEntry type="library" name="fasterxml.jackson.core.databind" level="project" />
   </component>
 </module>
\ No newline at end of file
Index: .idea/compiler.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"CompilerConfiguration\">\n    <annotationProcessing>\n      <profile name=\"Maven default annotation processors profile\" enabled=\"true\">\n        <sourceOutputDir name=\"target/generated-sources/annotations\" />\n        <sourceTestOutputDir name=\"target/generated-test-sources/test-annotations\" />\n        <outputRelativeToContentRoot value=\"true\" />\n        <module name=\"demo\" />\n      </profile>\n    </annotationProcessing>\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/compiler.xml b/.idea/compiler.xml
--- a/.idea/compiler.xml	(revision c480030d421db561c29453bbb71331faf3102cda)
+++ b/.idea/compiler.xml	(date 1711200104817)
@@ -7,6 +7,7 @@
         <sourceTestOutputDir name="target/generated-test-sources/test-annotations" />
         <outputRelativeToContentRoot value="true" />
         <module name="demo" />
+        <module name="ing-sw-2024-pucci-santarossa-ruggieri-sciarretta" />
       </profile>
     </annotationProcessing>
   </component>
Index: src/main/java/it/polimi/ingsw/model/Game.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\n\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.LinkedList;\n\npublic class Game {\n    private Queue<Player> playerQueue;\n    private int currentPlayerIndex;\n    private Player firstPlayer;\n    private boolean gameOver;\n    private CommonBoard common_board;\n    private ConcreteDeck resource_deck;\n    private ConcreteDeck gold_deck;\n\n\n    public Game() {\n        common_board = new CommonBoard(); //initializes the board\n        dealCards();\n        while (!isGameOver()) {\n            // Loop through players and handle each player's turn\n            for (Player player : playerQueue) {\n                placeCard(chooseCardToPlayFromHand());\n                updatePersonalScore(currentPlayerIndex);\n                drawCard(); //TODO: pesco da terra o dal mazzo a seconda di cosa sceglie l'utente\n            }\n            gameOver = isGameOver();\n        }\n        lastTurn();\n        calculateFinalScores();\n\n\n        // Perform end game actions (e.g., display winner)\n    }\n\n    public void addPlayer(Player player) {\n        playerQueue.add(player);\n    }\n\n\n    public void dealCards() {\n        // Deal cards to players\n        for (Player player : playerQueue) {\n            // Deal 2 cards from the resource deck\n            for (int i = 0; i < 2; i++) {\n                if (!resource_deck.isEmpty()) {\n                    Card card = resource_deck.pop(); // Remove the top card from the resource deck\n                    player.addToHand(card); // Add the card to the player's hand\n                }\n            }\n\n            // Deal 1 card from the gold deck\n            if (!gold_deck.isEmpty()) {\n                Card card = gold_deck.pop(); // Remove the top card from the gold deck\n                player.addToHand(card); // Add the card to the player's hand\n            }\n\n            //TODO: capire se vogliamo prendere 2 obiettivi dal deck obiettivi o scegliere 2 carte a caso\n        }\n    }\n\n\n    public int getCurrentPlayer() {\n        return currentPlayerIndex;\n    }\n\n\n    public void calculateFinalScores() {\n        // Calculate final scores\n        //Riceve da commonBoard le posizioni dell'ultimo giro + da personalBoard i punteggi degli obiettivi, per ciascun giocatore\n        //somma per ogni giocatore\n    }\n\n    public boolean isGameOver() {\n        return gameOver;\n    }\n\n    public Card chooseCardToPlayFromHand(){\n\n    }\n\n    public void placeCard(Card card_chosen){\n\n    }\n\n    public void updatePersonalScore(int currentPlayerIndex){\n\n    }\n\n    public void drawCard(){\n       //pattern dividere tra pesca da mazzo o dal banco (metodi già scritti in CommonBoard)\n    }\n\n    public void lastTurn(){\n        //gestisce il settaggio del partial_winner + tiene conto del fatto che sto giocando l'ultimo turno\n        //movePlayer (In commonBard notifica quando si arriva a 20, il game fa finire il turno corrente, ne fa fare un'altro completo\n        //e poi arresta il gioco\n    }\n\n\n    // Additional methods and logic as needed\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/Game.java b/src/main/java/it/polimi/ingsw/model/Game.java
--- a/src/main/java/it/polimi/ingsw/model/Game.java	(revision c480030d421db561c29453bbb71331faf3102cda)
+++ b/src/main/java/it/polimi/ingsw/model/Game.java	(date 1711200039893)
@@ -76,11 +76,9 @@
     }
 
     public Card chooseCardToPlayFromHand(){
-
     }
 
     public void placeCard(Card card_chosen){
-
     }
 
     public void updatePersonalScore(int currentPlayerIndex){
Index: src/main/java/it/polimi/ingsw/model/CardsCollection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Optional;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Iterator;\n\n\npublic  class CardsCollection {\n    public List<Card> cards;\n\n    public CardsCollection() {\n        cards = new ArrayList<>();\n    }\n\n    public void addCard(Card card) {\n        cards.add(card);\n    }\n\n    public int size() {\n        return cards.size();\n    }\n\n    /**\n     * To do: populateDeck read a .json file and populate the data structure using\n     * the constructors and the setters of Card subclasses.\n     */\n    // In this case we are creating only the FRONT, but we need also the back of the card.\n    public void populateDeck(String jsonFilePath, String type) {\n        ObjectMapper objectMapper = new ObjectMapper();\n        try {\n            JsonNode rootNode = objectMapper.readTree(new File(jsonFilePath));\n            JsonNode cardsNode = rootNode.path(\"cards\");\n\n            for (JsonNode cardNode : cardsNode) {\n\n                int id = cardNode.path(\"id\").asInt();\n                String colorStr = cardNode.path(\"color\").asText();\n                Color color = Color.valueOf(colorStr.toUpperCase());\n                Orientation orientation = Orientation.FRONT;\n                int score = cardNode.path(\"points\").asInt();\n\n                // This is the case where we have to create a ResourceCard.\n                // NE corner.\n                Corner[][] actual_corners = new Corner[2][2];\n                String NE_corner_content = cardNode.path(\"NE\").asText();\n                if (NE_corner_content.equals(\"NonVisible\")) {\n                    actual_corners[0][1].is_visible = false;\n                } else {\n                    if (NE_corner_content.equals(\"Mushroom\")) {\n                        actual_corners[0][1].setCornerResource(Resource.MUSHROOM);\n                    }\n                    if (NE_corner_content.equals(\"Butterfly\")) {\n                        actual_corners[0][1].setCornerResource(Resource.BUTTERFLY);\n                    }\n                    if (NE_corner_content.equals(\"Wolf\")) {\n                        actual_corners[0][1].setCornerResource(Resource.WOLF);\n                    }\n                    if (NE_corner_content.equals(\"Leaf\")) {\n                        actual_corners[0][1].setCornerResource(Resource.LEAF);\n                    }\n                    // This if the card has ITEM objects in the corner.\n                    if (NE_corner_content.equals(\"Potion\")) {\n                        actual_corners[0][1].setCornerItem(Item.POTION);\n                    }\n                    if (NE_corner_content.equals(\"Feather\")) {\n                        actual_corners[0][1].setCornerItem(Item.FEATHER);\n                    }\n                    if (NE_corner_content.equals(\"Parchment\")) {\n                        actual_corners[0][1].setCornerItem(Item.PARCHMENT);\n                    }\n                }\n                // SE Corner.\n                String SE_corner_content = cardNode.path(\"SE\").asText();\n                if (SE_corner_content.equals(\"NonVisible\")) {\n                    actual_corners[1][0].is_visible = false;\n                } else {\n                    if (SE_corner_content.equals(\"Mushroom\")) {\n                        actual_corners[1][0].setCornerResource(Resource.MUSHROOM);\n                    }\n                    if (SE_corner_content.equals(\"Butterfly\")) {\n                        actual_corners[1][0].setCornerResource(Resource.BUTTERFLY);\n                    }\n                    if (SE_corner_content.equals(\"Wolf\")) {\n                        actual_corners[1][0].setCornerResource(Resource.WOLF);\n                    }\n                    if (SE_corner_content.equals(\"Leaf\")) {\n                        actual_corners[1][0].setCornerResource(Resource.LEAF);\n                    }\n                    // This if the card has ITEM objects in the corner.\n                    if (SE_corner_content.equals(\"Potion\")) {\n                        actual_corners[1][0].setCornerItem(Item.POTION);\n                    }\n                    if (SE_corner_content.equals(\"Feather\")) {\n                        actual_corners[1][0].setCornerItem(Item.FEATHER);\n                    }\n                    if (SE_corner_content.equals(\"Parchment\")) {\n                        actual_corners[1][0].setCornerItem(Item.PARCHMENT);\n                    }\n                }\n                // NO corner.\n                String NO_corner_content = cardNode.path(\"NO\").asText();\n                if (NO_corner_content.equals(\"NonVisible\")) {\n                    actual_corners[0][1].is_visible = false;\n                } else {\n                    if (NO_corner_content.equals(\"Mushroom\")) {\n                        actual_corners[0][1].setCornerResource(Resource.MUSHROOM);\n                    }\n                    if (NO_corner_content.equals(\"Butterfly\")) {\n                        actual_corners[0][1].setCornerResource(Resource.BUTTERFLY);\n                    }\n                    if (NO_corner_content.equals(\"Wolf\")) {\n                        actual_corners[0][1].setCornerResource(Resource.WOLF);\n                    }\n                    if (NO_corner_content.equals(\"Leaf\")) {\n                        actual_corners[0][1].setCornerResource(Resource.LEAF);\n                    }\n                    // This if the card has ITEM objects in the corner.\n                    if (NO_corner_content.equals(\"Potion\")) {\n                        actual_corners[0][1].setCornerItem(Item.POTION);\n                    }\n                    if (NO_corner_content.equals(\"Feather\")) {\n                        actual_corners[0][1].setCornerItem(Item.FEATHER);\n                    }\n                    if (NO_corner_content.equals(\"Parchment\")) {\n                        actual_corners[0][1].setCornerItem(Item.PARCHMENT);\n                    }\n                }\n                // SO corner.\n                String SO_corner_content = cardNode.path(\"SO\").asText();\n                if (SO_corner_content.equals(\"NonVisible\")) {\n                    actual_corners[1][1].is_visible = false;\n                } else {\n                    if (SO_corner_content.equals(\"Mushroom\")) {\n                        actual_corners[1][1].setCornerResource(Resource.MUSHROOM);\n                    }\n                    if (SO_corner_content.equals(\"Butterfly\")) {\n                        actual_corners[1][1].setCornerResource(Resource.BUTTERFLY);\n                    }\n                    if (SO_corner_content.equals(\"Wolf\")) {\n                        actual_corners[1][1].setCornerResource(Resource.WOLF);\n                    }\n                    if (SO_corner_content.equals(\"Leaf\")) {\n                        actual_corners[1][1].setCornerResource(Resource.LEAF);\n                    }\n                    // This if the card has ITEM objects in the corner.\n                    if (SO_corner_content.equals(\"Potion\")) {\n                        actual_corners[1][1].setCornerItem(Item.POTION);\n                    }\n                    if (SO_corner_content.equals(\"Feather\")) {\n                        actual_corners[1][1].setCornerItem(Item.FEATHER);\n                    }\n                    if (SO_corner_content.equals(\"Parchment\")) {\n                        actual_corners[1][1].setCornerItem(Item.PARCHMENT);\n                    }\n                }\n                if (cardNode.path(\"type\").asText().equals(\"Resource\") && type.equals(\"Resource\")){\n                    ResourceCard card = new ResourceCard(id, orientation, color, score, actual_corners);\n                    // Qui potresti settare ulteriori proprietà specifiche per ResourceCard\n                    this.addCard(card);\n                }\n\n                if (cardNode.path(\"type\").asText().equals(\"Gold\") && type.equals(\"Gold\")){\n                    int MushroomRequired = cardNode.path(\"MushroomRequired\").asInt();\n                    int ButterflyRequired = cardNode.path(\"ButterflyRequired\").asInt();\n                    int WolfRequired = cardNode.path(\"WolfRequired\").asInt();\n                    int LeafRequired = cardNode.path(\"LeafRequired\").asInt();\n\n                    // Item_for_score\n                    int PotionCount = cardNode.path(\"PotionCount\").asInt();\n                    int FeatherCount = cardNode.path(\"FeatherCount\").asInt();\n                    int ParchmentCount = cardNode.path(\"ParchmentCount\").asInt();\n                    int CoverCorners = cardNode.path(\"CoverCorners\").asInt();\n\n                    // Problem: Item optional!\n                    Optional<Item> item_for_score = Optional.empty();\n                    if (PotionCount == 1) {\n                        item_for_score = Optional.of(Item.POTION);\n                    }\n                    if (FeatherCount == 1) {\n                        item_for_score = Optional.of(Item.FEATHER);\n                    }\n                    if (ParchmentCount == 1) {\n                        item_for_score = Optional.of(Item.PARCHMENT);\n                    }\n\n                    GoldCard gold_card = new GoldCard(id, orientation, color);\n                    gold_card.setGoldCard(item_for_score, CoverCorners, MushroomRequired, LeafRequired, ButterflyRequired, WolfRequired);\n                    this.addCard(gold_card);\n                }\n            }\n            System.out.println(\"Deck populated successfully.\");\n        } catch (Exception e) {\n            System.err.println(\"Error populating deck: \" + e.getMessage());\n        }\n    }\n\n    // to do: then starter cards and objective cards;\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/CardsCollection.java b/src/main/java/it/polimi/ingsw/model/CardsCollection.java
--- a/src/main/java/it/polimi/ingsw/model/CardsCollection.java	(revision c480030d421db561c29453bbb71331faf3102cda)
+++ b/src/main/java/it/polimi/ingsw/model/CardsCollection.java	(date 1711200593008)
@@ -27,7 +27,7 @@
     }
 
     /**
-     * To do: populateDeck read a .json file and populate the data structure using
+     * TODO: populateDeck read a .json file and populate the data structure using
      * the constructors and the setters of Card subclasses.
      */
     // In this case we are creating only the FRONT, but we need also the back of the card.
